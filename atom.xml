<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>luka.tw</title>
  
  
  <link href="https://luka.tw/atom.xml" rel="self"/>
  
  <link href="https://luka.tw/"/>
  <updated>2023-04-25T09:26:41.608Z</updated>
  <id>https://luka.tw/</id>
  
  <author>
    <name>Luka Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【 Flask 教學 】在 Flask 中操作 Cookie</title>
    <link href="https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/06-flask-cookie-116296aaa947/"/>
    <id>https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/06-flask-cookie-116296aaa947/</id>
    <published>2023-02-16T06:02:01.000Z</published>
    <updated>2023-04-25T09:26:41.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何在-Flask-設置和操作-Cookie"><a href="#如何在-Flask-設置和操作-Cookie" class="headerlink" title="如何在 Flask 設置和操作 Cookie"></a>如何在 Flask 設置和操作 Cookie</h1><p>在 Python Flask 中，cookie 是一種儲存在使用者瀏覽器中的小型資料塊。通常情況下，我們使用 cookie 來記錄使用者的首選設定、登錄資料以及其他與使用者相關的資訊。在 Flask 應用程式中，使用 cookie 的過程非常簡單。</p><h2 id="設置-cookie"><a href="#設置-cookie" class="headerlink" title="設置 cookie"></a>設置 cookie</h2><p>要在 Flask 中設置 cookie，我們需要使用 response 物件的 <code>set_cookie()</code> 方法。這個方法接受以下參數：</p><ul><li>  <code>key</code>：cookie 的名稱，必須是一個字符串</li><li>  <code>value</code>：cookie 的值，必須是一個字符串，默認為空字符串</li><li>  <code>max_age</code>：cookie 的存活時間，以秒為單位，默認為 None</li></ul><p>以下是一個簡單的 Flask 應用程式，演示如何設置 cookie：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, make_response<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    resp = make_response(<span class="hljs-string">&#x27;Setting a cookie!&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;my_cookie&#x27;</span>, <span class="hljs-string">&#x27;my_value&#x27;</span>)<br>    <span class="hljs-keyword">return</span> resp<br></code></pre></td></tr></table></figure><p>在上面的程式碼中，我們建立了一個名為 <code>my_cookie</code> 的 cookie，其值為 <code>my_value</code>。當使用者訪問該頁面時，他們的瀏覽器將接收到這個 cookie。</p><h2 id="讀取-cookie"><a href="#讀取-cookie" class="headerlink" title="讀取 cookie"></a>讀取 cookie</h2><p>要讀取 cookie，我們可以使用 request 物件的 <code>cookies</code> 屬性。這個屬性是一個字典，其中包含了所有使用者瀏覽器中的 cookie。以下是一個簡單的 Flask 應用程式，演示如何讀取 cookie：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    my_cookie = request.cookies.get(<span class="hljs-string">&#x27;my_cookie&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;The value of my_cookie is <span class="hljs-subst">&#123;my_cookie&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的程式碼中，我們使用 <code>request.cookies.get()</code> 方法讀取名為 <code>my_cookie</code> 的 cookie。如果該 cookie 存在，它的值將被存儲在 <code>my_cookie</code> 變數中。否則，<code>my_cookie</code> 將為 <code>None</code>。</p><h2 id="刪除-cookie"><a href="#刪除-cookie" class="headerlink" title="刪除 cookie"></a>刪除 cookie</h2><p>要刪除 cookie，我們只需要設置 cookie 的 <code>max_age</code> 參數為 0。以下是一個簡單的 Flask 應用程式，演示如何刪除 cookie：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, make_response<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    resp = make_response(<span class="hljs-string">&#x27;Deleting a cookie!&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;my_cookie&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, max_age=<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> resp<br></code></pre></td></tr></table></figure><p>在上面的程式碼中，我們建立了一個名為 <code>my_cookie</code> 的 cookie，並將其 <code>max_age</code> 設置為 0。這意味著該 cookie 的存活時間為 0 秒，瀏覽器將立即刪除它。</p><h2 id="使用-session"><a href="#使用-session" class="headerlink" title="使用 session"></a>使用 session</h2><p>雖然 cookie 是一種非常方便的儲存使用者設置和資料的方式，但是在一些情況下，它們可能不夠安全。為了增強安全性，Flask 提供了一種名為 session 的機制，它會在伺服器端儲存使用者資料，並使用一個加密的 cookie 將使用者資料傳遞給使用者瀏覽器。以下是一個簡單的 Flask 應用程式，演示如何使用 session：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, session<br><br>app = Flask(__name__)<br>app.secret_key = <span class="hljs-string">&#x27;my_secret_key&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    session[<span class="hljs-string">&#x27;my_session&#x27;</span>] = <span class="hljs-string">&#x27;my_value&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Setting a session!&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/get_session&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_session</span>():</span><br>    my_session = session.get(<span class="hljs-string">&#x27;my_session&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;The value of my_session is <span class="hljs-subst">&#123;my_session&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的程式碼中，我們使用 <code>session</code> 物件儲存使用者資料。在設置 session 時，我們可以像設置字典一樣設置 session 的鍵和值。在讀取 session 時，我們使用 <code>session.get()</code> 方法。需要注意的是，使用 session 時需要設置 <code>app.secret_key</code> 屬性，該屬性是用於加密 session 的關鍵。</p><h1 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h1><p>以下是使用 Python Flask 框架來實現一些使用 Cookie 的範例：</p><h2 id="使用者身份驗證"><a href="#使用者身份驗證" class="headerlink" title="使用者身份驗證"></a>使用者身份驗證</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, make_response<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    resp = make_response(<span class="hljs-string">&#x27;Welcome!&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;user_id&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>)<br>    <span class="hljs-keyword">return</span> resp<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/dashboard&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dashboard</span>():</span><br>    user_id = request.cookies.get(<span class="hljs-string">&#x27;user_id&#x27;</span>)<br>    <span class="hljs-keyword">if</span> user_id == <span class="hljs-string">&#x27;123&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Dashboard&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Unauthorized&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的程式碼中，當使用者訪問首頁時，我們設置了一個名為 <code>user_id</code> 的 cookie，其值為 <code>123</code>。當使用者訪問儀表板頁面時，我們讀取了 <code>user_id</code> cookie 的值，並檢查其是否等於 <code>123</code>。如果相等，則返回儀表板頁面，否則返回未經授權的錯誤。</p><h2 id="記住使用者首選設置"><a href="#記住使用者首選設置" class="headerlink" title="記住使用者首選設置"></a>記住使用者首選設置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, make_response<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    lang = request.cookies.get(<span class="hljs-string">&#x27;lang&#x27;</span>, <span class="hljs-string">&#x27;en&#x27;</span>)<br>    resp = make_response(<span class="hljs-string">f&#x27;Language: <span class="hljs-subst">&#123;lang&#125;</span>&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;lang&#x27;</span>, lang)<br>    <span class="hljs-keyword">return</span> resp<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/set_lang/&lt;lang&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_lang</span>(<span class="hljs-params">lang</span>):</span><br>    resp = make_response(<span class="hljs-string">&#x27;Language set!&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;lang&#x27;</span>, lang)<br>    <span class="hljs-keyword">return</span> resp<br></code></pre></td></tr></table></figure><p>在上面的程式碼中，我們讀取了名為 <code>lang</code> 的 cookie 的值，並將其用作網站的語言。如果 cookie 不存在，我們默認使用英語。當使用者訪問網站時，我們將 <code>lang</code> cookie 的值設置為當前語言。如果使用者訪問 <code>/set_lang/&lt;lang&gt;</code> 頁面，我們將 <code>lang</code> cookie 的值設置為使用者指定的語言。</p><h2 id="記住使用者在線狀態"><a href="#記住使用者在線狀態" class="headerlink" title="記住使用者在線狀態"></a>記住使用者在線狀態</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, make_response<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    resp = make_response(<span class="hljs-string">&#x27;Welcome!&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;online&#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>)<br>    <span class="hljs-keyword">return</span> resp<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/logout&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout</span>():</span><br>    resp = make_response(<span class="hljs-string">&#x27;Logged out!&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;online&#x27;</span>, <span class="hljs-string">&#x27;false&#x27;</span>)<br>    <span class="hljs-keyword">return</span> resp<br></code></pre></td></tr></table></figure><p>在上面的程式碼中，當使用者訪問首頁時，我們設置了一個名為 <code>online</code> 的 cookie，其值為 <code>true</code>，表示使用者在線。當使用者訪問登出頁面時，我們將 <code>online</code> cookie 的值設置為 <code>false</code>，表示使用者離線。</p><h2 id="記住使用者的購物車"><a href="#記住使用者的購物車" class="headerlink" title="記住使用者的購物車"></a>記住使用者的購物車</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, make_response<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    resp = make_response(<span class="hljs-string">&#x27;Welcome to our store!&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;cart&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">return</span> resp<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/add_to_cart/&lt;item&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_to_cart</span>(<span class="hljs-params">item</span>):</span><br>    cart = request.cookies.get(<span class="hljs-string">&#x27;cart&#x27;</span>)<br>    <span class="hljs-keyword">if</span> cart:<br>        cart += <span class="hljs-string">f&#x27;,<span class="hljs-subst">&#123;item&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        cart = item<br>    resp = make_response(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;item&#125;</span> added to cart!&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;cart&#x27;</span>, cart)<br>    <span class="hljs-keyword">return</span> resp<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/view_cart&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">view_cart</span>():</span><br>    cart = request.cookies.get(<span class="hljs-string">&#x27;cart&#x27;</span>)<br>    <span class="hljs-keyword">if</span> cart:<br>        items = cart.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Items in your cart: <span class="hljs-subst">&#123;<span class="hljs-string">&quot;, &quot;</span>.join(items)&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Your cart is empty&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的程式碼中，當使用者訪問首頁時，我們設置了一個名為 <code>cart</code> 的 cookie，其值為空，表示使用者的購物車是空的。當使用者訪問添加到購物車頁面時，我們讀取 <code>cart</code> cookie 的值，將新的項目添加到購物車中，然後更新 <code>cart</code> cookie 的值。當使用者訪問查看購物車頁面時，我們讀取 <code>cart</code> cookie 的值，並顯示購物車中的所有項目。</p><h2 id="記住使用者的瀏覽歷史"><a href="#記住使用者的瀏覽歷史" class="headerlink" title="記住使用者的瀏覽歷史"></a>記住使用者的瀏覽歷史</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, make_response<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    resp = make_response(<span class="hljs-string">&#x27;Welcome to our store!&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;history&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">return</span> resp<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/view_product/&lt;product&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">view_product</span>(<span class="hljs-params">product</span>):</span><br>    history = request.cookies.get(<span class="hljs-string">&#x27;history&#x27;</span>)<br>    <span class="hljs-keyword">if</span> history:<br>        products = history.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <span class="hljs-keyword">if</span> product <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> products:<br>            history += <span class="hljs-string">f&#x27;,<span class="hljs-subst">&#123;product&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        history = product<br>    resp = make_response(<span class="hljs-string">f&#x27;Viewing product: <span class="hljs-subst">&#123;product&#125;</span>&#x27;</span>)<br>    resp.set_cookie(<span class="hljs-string">&#x27;history&#x27;</span>, history)<br>    <span class="hljs-keyword">return</span> resp<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/view_history&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">view_history</span>():</span><br>    history = request.cookies.get(<span class="hljs-string">&#x27;history&#x27;</span>)<br>    <span class="hljs-keyword">if</span> history:<br>        products = history.split<br></code></pre></td></tr></table></figure><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>在 Flask 中，使用 cookie 是一種非常簡單和方便的方式，可以儲存使用者設置和資料。在上面的教學中，我們學習了如何設置、讀取和刪除 cookie，以及如何使用 session 增強安全性。通過這些方法，我們可以更加靈活地設計 Flask 應用程式，以滿足不同的需求。</p><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ol><li><p> <a href="https://overiq.com/flask-101/cookies-in-flask/">OverIQ</a>：簡單介紹 Flask 中如何使用 <code>set_cookie()</code> 方法設置 cookie。</p></li><li><p><a href="https://www.geeksforgeeks.org/flask-cookies/">GeeksforGeeks</a>：提供 Flask cookie 的概述，並介紹如何設置和讀取 cookie。</p></li><li><p><a href="https://flask.palletsprojects.com/en/2.2.x/quickstart/">Flask documentation</a>：官方 Flask 文件，提供全面的關於 cookie 的指南，包括如何設置、讀取、刪除 cookie，以及使用 session。</p></li><li><p><a href="https://pythonbasics.org/flask-cookies/">Python Basics</a>：簡單介紹在 Flask 中如何使用 <code>make_response()</code> 函數和 <code>set_cookie()</code> 方法來設置 cookie。</p></li><li><p><a href="https://stackoverflow.com/questions/46661083/how-to-set-cookie-in-python-flask">Stack Overflow</a>：Stack Overflow 討論串，討論了在 Flask 中設置 cookie 會面臨的問題以及如何解決。</p></li><li><p> <a href="http://protutorialplus.com/flask-cookies">Protutorialplus</a>：提供了如何在 Python Flask 中設置和讀取 cookie 的簡單教學。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何在-Flask-設置和操作-Cookie&quot;&gt;&lt;a href=&quot;#如何在-Flask-設置和操作-Cookie&quot; class=&quot;headerlink&quot; title=&quot;如何在 Flask 設置和操作 Cookie&quot;&gt;&lt;/a&gt;如何在 Flask 設置和操作 Cook</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="Flask 教學" scheme="https://luka.tw/categories/Python/Flask-%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Flask 教學 】 網址傳遞參數與表單傳遞參數</title>
    <link href="https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/dynanic_route_and_forms-af7b5d76feea/"/>
    <id>https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/dynanic_route_and_forms-af7b5d76feea/</id>
    <published>2023-02-16T06:02:01.000Z</published>
    <updated>2023-04-25T09:39:23.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通過-URL-傳遞參數"><a href="#通過-URL-傳遞參數" class="headerlink" title="通過 URL 傳遞參數"></a>通過 URL 傳遞參數</h1><h2 id="嗨，動態路由你好！"><a href="#嗨，動態路由你好！" class="headerlink" title="嗨，動態路由你好！"></a>嗨，動態路由你好！</h2><p>Flask 是一個輕量級的 Web 框架，提供了簡單易用的路由定義和視圖函數。其中一個優勢是通過 URL 傳遞參數的能力，也就是動態路由。在這個路由方式下，URL 中的一部分可以作為參數傳遞到視圖函數中，從而實現不同的動態內容呈現。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/greet/&lt;name&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&#x27;</span><br></code></pre></td></tr></table></figure><p>此路由接受 URL 中的 <code>name</code> 參數，我們可以通過 <code>name</code> 參數在函數中訪問它。例如，如果我們輸入網址 <code>http://localhost:5000/greet/Bob</code>，我們將在頁面上看到 “Hello, Bob!”。</p><p>在 Flask 中，使用動態路由需要在路由定義中使用 <code>&lt;parameter_name&gt;</code> 語法，指定要傳遞的參數名稱。這個參數可以是任何類型的資料，包括整數、字符串、浮點數等等。在視圖函數中，我們可以使用這個參數來生成不同的內容。</p><h2 id="根據網址的文章-id-導向該篇文章"><a href="#根據網址的文章-id-導向該篇文章" class="headerlink" title="根據網址的文章 id 導向該篇文章"></a>根據網址的文章 id 導向該篇文章</h2><p>下面我們來看一個具體的例子，假設我們有一個博客網站，每一篇文章都有一個獨特的 ID，我們希望通過 URL 顯示不同的文章內容。那麼，我們可以使用以下的路由定義：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article/&lt;int:article_id&gt;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_article</span>(<span class="hljs-params">article_id</span>):</span><br>    <span class="hljs-comment"># 在這裡使用 article_id 來顯示文章內容</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;這是文章 %d 的內容&#x27;</span> % article_id<br></code></pre></td></tr></table></figure><p>在上述程式碼中，<code>&lt;int:article_id&gt;</code> 指定了我們要傳遞一個整數類型的參數 <code>article_id</code>。在視圖函數 <code>show_article</code> 中，我們使用了這個參數來顯示文章內容。這個函數只是一個簡單的範例，實際情況中，我們可以從資料庫中獲取文章內容，然後將其呈現在網頁上。</p><p>當使用者訪問 <code>/article/123</code> 時，Flask 會自動提取 URL 中的 <code>123</code>，並將其傳遞到 <code>show_article</code> 視圖函數中。因為我們使用了 <code>&lt;int:article_id&gt;</code>，Flask 會自動確認 <code>123</code> 是一個整數類型的資料，並將其轉換成 <code>article_id</code> 參數的值。然後，視圖函數會使用 <code>article_id</code> 來顯示文章內容。</p><h2 id="顯示名稱為-username-的使用者資料"><a href="#顯示名稱為-username-的使用者資料" class="headerlink" title="顯示名稱為 username 的使用者資料"></a>顯示名稱為 username 的使用者資料</h2><p>在 Flask 中，我們可以使用多個動態路由參數，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/@app.route(&#x27;</span>/user/&lt;username&gt;/<span class="hljs-built_in">int</span>:user_id<span class="hljs-string">&#x27;)</span></span></span><br><span class="hljs-string"><span class="hljs-params"><span class="hljs-meta">def show_user(username, user_id):</span></span></span><br><span class="hljs-string"><span class="hljs-params"><span class="hljs-meta">  # 在這裡使用 username 和 user_id 來顯示使用者資料</span></span></span><br><span class="hljs-string"><span class="hljs-params"><span class="hljs-meta">  return &#x27;</span>使用者名是 %s，ID 是 %d<span class="hljs-string">&#x27; % (username, user_id)</span></span></span><br></code></pre></td></tr></table></figure><p>在這個路由定義中，我們使用了兩個動態路由參數，<code>&lt;username&gt;</code> 和 <code>&lt;int:user_id&gt;</code>。在視圖函數 <code>show_user</code> 中，我們使用了這兩個參數來顯示使用者資料。</p><h2 id="動態路由注意事項"><a href="#動態路由注意事項" class="headerlink" title="動態路由注意事項"></a>動態路由注意事項</h2><p>使用動態路由時需要注意以下幾點：</p><ol><li>參數的類型必須指定。在上面的例子中，我們使用 <code>&lt;int:article_id&gt;</code> 和 <code>&lt;username&gt;</code> 指定了參數的類型。</li><li>參數名稱必須和視圖函數中的參數名稱相同。</li><li>參數的類型轉換是自動進行的，如果轉換失敗，Flask 會返回 404 錯誤頁面。</li></ol><p>總而言之，動態路由是 Flask 提供的一個強大的功能，可以讓我們通過 URL 傳遞參數，實現不同的動態內容呈現。通過 <code>&lt;parameter_name&gt;</code> 語法指定參數名稱和類型，在視圖函數中使用參數來生成不同的內容。使用時需要注意參數類型和名稱，以及類型轉換可能出現的錯誤。</p><h1 id="透過表單傳遞資料"><a href="#透過表單傳遞資料" class="headerlink" title="透過表單傳遞資料"></a>透過表單傳遞資料</h1><p>以下是一個簡單的 Flask 程式，可以處理表單資料：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template, request<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/submit&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">submit</span>():</span><br>    name = request.form.get(<span class="hljs-string">&#x27;name&#x27;</span>)<br>    age = request.form.get(<span class="hljs-string">&#x27;age&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Hello <span class="hljs-subst">&#123;name&#125;</span>, you are <span class="hljs-subst">&#123;age&#125;</span> years old!&#x27;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>這個程式定義了兩個路由：</p><ul><li><code>/</code>：顯示一個網頁，該網頁包含一個表單，該表單要求使用者輸入姓名和年齡。</li><li><code>/submit</code>：處理提交的表單資料，並顯示一條歡迎消息，包含使用者的姓名和年齡。</li></ul><p>這個程式需要一個名為 <code>index.html</code> 的模板文件，該文件定義了表單的 HTML 程式碼。以下是 <code>index.html</code> 的範例程式碼：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Flask Form Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Enter your name and age:<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/submit&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Name:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>Age:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>這個模板文件顯示一個表單，要求使用者輸入姓名和年齡，然後提交表單。表單使用 POST 方法提交到 <code>/submit</code> 路由。</p><p>當使用者提交表單時，Flask 調用 <code>submit</code> 函數處理表單資料。這個函數從 <code>request</code> 對象中獲取 <code>name</code> 和 <code>age</code> 字段的值，然後使用這些值顯示一條歡迎消息。</p><p>請注意，在實際應用中，您應該對提交的資料進行驗證和清理，以防止不良使用者輸入無效資料或惡意資料。您還應該對資料進行適當的安全處理，以保護您的應用免受攻擊。</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>在這個教學中，我們學習了如何在 Flask 中定義路由以及如何處理 URL 參數和表單資料。Flask 為構建 Web 應用程式提供了一個靈活而強大的框架，了解如何定義路由是構建任何 Flask 應用程式的關鍵部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通過-URL-傳遞參數&quot;&gt;&lt;a href=&quot;#通過-URL-傳遞參數&quot; class=&quot;headerlink&quot; title=&quot;通過 URL 傳遞參數&quot;&gt;&lt;/a&gt;通過 URL 傳遞參數&lt;/h1&gt;&lt;h2 id=&quot;嗨，動態路由你好！&quot;&gt;&lt;a href=&quot;#嗨，動態路由你好</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="Flask 教學" scheme="https://luka.tw/categories/Python/Flask-%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Flask 教學 】用 Flask Blueprint 組織程式碼</title>
    <link href="https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/05-flask-blueprint-fe613c4944ef/"/>
    <id>https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/05-flask-blueprint-fe613c4944ef/</id>
    <published>2023-02-16T05:05:01.000Z</published>
    <updated>2023-04-25T09:10:45.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flask-Blueprint-組織程式碼的幾種方式"><a href="#Flask-Blueprint-組織程式碼的幾種方式" class="headerlink" title="Flask Blueprint 組織程式碼的幾種方式"></a>Flask Blueprint 組織程式碼的幾種方式</h1><p>Blueprint 是一個用於標示架構和組織軟體專案的概念。在這裡，我們將探討三種不同的專案組織方式：單一應用程式、模組化應用程式，以及使用 Flask Blueprint 的應用程式。以下是這三種組織方式的程式範例：</p><h2 id="按功能劃分藍圖"><a href="#按功能劃分藍圖" class="headerlink" title="按功能劃分藍圖"></a>按功能劃分藍圖</h2><p>在這種組織方式中，我們根據應用程式的功能劃分藍圖。這個範例包含了一個簡單的 Flask 應用程式，使用了按功能劃分的 Blueprint 組織方式。應用程式有兩個功能模塊：身份驗證（auth）和文章（posts）。每個模塊都有自己的視圖和模板。在 app.py 中，我們註冊了兩個藍圖：auth_blueprint 和 posts_blueprint。</p><p>目錄結構：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">myproject/<br>    ├── auth/<br>    │   ├── __init__.py<br>    │   ├── views.py<br>    ├── posts/<br>    │   ├── __init__.py<br>    │   ├── views.py<br>    ├── templates/<br>    │   ├── auth/<br>    │   │   ├── login.html<br>    │   ├── posts/<br>    │   │   ├── list.html<br>    └── app.py<br></code></pre></td></tr></table></figure><p>app.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> auth.views <span class="hljs-keyword">import</span> auth_blueprint<br><span class="hljs-keyword">from</span> posts.views <span class="hljs-keyword">import</span> posts_blueprint<br><br>app = Flask(__name__)<br>app.register_blueprint(auth_blueprint)<br>app.register_blueprint(posts_blueprint)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>auth/<strong>init</strong>.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 空文件</span><br></code></pre></td></tr></table></figure><p>auth/views.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Blueprint, render_template<br><br>auth_blueprint = Blueprint(<span class="hljs-string">&#x27;auth&#x27;</span>, __name__, template_folder=<span class="hljs-string">&#x27;templates/auth&#x27;</span>)<br><br><span class="hljs-meta">@auth_blueprint.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;auth/login.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>templates/auth/login.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Login Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>posts/<strong>init</strong>.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 空文件</span><br></code></pre></td></tr></table></figure><p>posts/views.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Blueprint, render_template<br><br>posts_blueprint = Blueprint(<span class="hljs-string">&#x27;posts&#x27;</span>, __name__, template_folder=<span class="hljs-string">&#x27;templates/posts&#x27;</span>)<br><br><span class="hljs-meta">@posts_blueprint.route(<span class="hljs-params"><span class="hljs-string">&#x27;/posts&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">list_posts</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;posts/list.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>templates/posts/list.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Posts<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Posts List<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="按角色劃分藍圖"><a href="#按角色劃分藍圖" class="headerlink" title="按角色劃分藍圖"></a>按角色劃分藍圖</h2><p>在這種組織方式中，我們根據不同的使用者角色（如管理員、使用者…等）劃分藍圖。這樣可以讓應用程式的不同角色有各自的功能界面和邏輯。以下是按角色劃分 Blueprint 的簡單範例：</p><p>目錄結構：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">myproject<span class="hljs-operator">/</span><br>    ├── admin<span class="hljs-operator">/</span><br>    │   ├── __init__.py<br>    │   ├── views.py<br>    ├── <span class="hljs-keyword">user</span><span class="hljs-operator">/</span><br>    │   ├── __init__.py<br>    │   ├── views.py<br>    ├── templates<span class="hljs-operator">/</span><br>    │   ├── admin<span class="hljs-operator">/</span><br>    │   │   ├── dashboard.html<br>    │   ├── <span class="hljs-keyword">user</span><span class="hljs-operator">/</span><br>    │   │   ├── profile.html<br>    └── app.py<br></code></pre></td></tr></table></figure><p>app.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> admin.views <span class="hljs-keyword">import</span> admin_blueprint<br><span class="hljs-keyword">from</span> user.views <span class="hljs-keyword">import</span> user_blueprint<br><br>app = Flask(__name__)<br>app.register_blueprint(admin_blueprint, url_prefix=<span class="hljs-string">&#x27;/admin&#x27;</span>)<br>app.register_blueprint(user_blueprint, url_prefix=<span class="hljs-string">&#x27;/user&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>admin/<strong>init</strong>.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 空文件</span><br></code></pre></td></tr></table></figure><p>admin/views.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Blueprint, render_template<br><br>admin_blueprint = Blueprint(<span class="hljs-string">&#x27;admin&#x27;</span>, __name__, template_folder=<span class="hljs-string">&#x27;templates/admin&#x27;</span>)<br><br><span class="hljs-meta">@admin_blueprint.route(<span class="hljs-params"><span class="hljs-string">&#x27;/dashboard&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dashboard</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;admin/dashboard.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>templates/admin/dashboard.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Admin Dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Admin Dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>user/<strong>init</strong>.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 空文件</span><br></code></pre></td></tr></table></figure><p>user/views.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Blueprint, render_template<br><br>user_blueprint = Blueprint(<span class="hljs-string">&#x27;user&#x27;</span>, __name__, template_folder=<span class="hljs-string">&#x27;templates/user&#x27;</span>)<br><br><span class="hljs-meta">@user_blueprint.route(<span class="hljs-params"><span class="hljs-string">&#x27;/profile&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">profile</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;user/profile.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>templates/user/profile.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>User Profile<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>User Profile<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一個範例按照角色劃分，有 admin 和 user 兩個角色，每個角色有對應的視圖和模板。<br>這些範例分別展示了按角色劃分和按資源劃分的兩種 Flask Blueprint 組織方式。</p><h2 id="按資源類型劃分藍圖："><a href="#按資源類型劃分藍圖：" class="headerlink" title="按資源類型劃分藍圖："></a>按資源類型劃分藍圖：</h2><p>在這種組織方式中，我們根據應用程式中的資源類型（如文章、評論等）劃分藍圖。這樣可以讓程式碼更具模組化，便於維護和擴展。在 app.py 中，我們註冊了相應的藍圖。</p><p>目錄結構：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">myproject/<br>    ├── posts/<br>    │   ├── __init__.py<br>    │   ├── views.py<br>    ├── comments/<br>    │   ├── __init__.py<br>    │   ├── views.py<br>    ├── templates/<br>    │   ├── posts/<br>    │   │   ├── list.html<br>    │   ├── comments/<br>    │   │   ├── list.html<br>    └── app.py<br></code></pre></td></tr></table></figure><p>app.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> posts.views <span class="hljs-keyword">import</span> posts_blueprint<br><span class="hljs-keyword">from</span> comments.views <span class="hljs-keyword">import</span> comments_blueprint<br><br>app = Flask(__name__)<br>app.register_blueprint(posts_blueprint, url_prefix=<span class="hljs-string">&#x27;/posts&#x27;</span>)<br>app.register_blueprint(comments_blueprint, url_prefix=<span class="hljs-string">&#x27;/comments&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>posts/<strong>init</strong>.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 空文件</span><br></code></pre></td></tr></table></figure><p>posts/views.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Blueprint, render_template<br><br>posts_blueprint = Blueprint(<span class="hljs-string">&#x27;posts&#x27;</span>, __name__, template_folder=<span class="hljs-string">&#x27;templates/posts&#x27;</span>)<br><br><span class="hljs-meta">@posts_blueprint.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">list_posts</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;posts/list.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>templates/posts/list.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Posts<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Posts List<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>comments/<strong>init</strong>.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 空文件</span><br></code></pre></td></tr></table></figure><p>comments/views.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Blueprint, render_template<br><br>comments_blueprint = Blueprint(<span class="hljs-string">&#x27;comments&#x27;</span>, __name__, template_folder=<span class="hljs-string">&#x27;templates/comments&#x27;</span>)<br><br><span class="hljs-meta">@comments_blueprint.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">list_comments</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;comments/list.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>templates/comments/list.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Comments<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Comments List<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="比較三種方案"><a href="#比較三種方案" class="headerlink" title="比較三種方案"></a>比較三種方案</h1><p>下表對比了使用 Flask Blueprint 組織程式碼的三種方式的優缺點：</p><table><thead><tr><th>方式</th><th>優點</th><th>缺點</th></tr></thead><tbody><tr><td>按功能劃分藍圖</td><td>功能模塊清晰</td><td>功能模塊過多時結構可能變得複雜</td></tr><tr><td></td><td>有利於專案的擴展性和可維護性</td><td></td></tr><tr><td>按角色劃分藍圖</td><td>便於實現角色之間的隔離和權限控制</td><td>角色之間存在相似功能時可能導致程式碼重複</td></tr><tr><td></td><td>有利於專案的擴展性和可維護性</td><td></td></tr><tr><td>按資源類型劃分藍圖</td><td>程式碼具有高度模組化</td><td>資源之間有相互依賴時可能需要更多的協調和溝通</td></tr><tr><td></td><td>便於維護和擴展</td><td></td></tr></tbody></table><p>在選擇組織方式時，應該根據專案的需求和規模來決定。有時候，可以將這些組織方式結合使用，以便更好地滿足專案需求。</p><h1 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h1><p>綜合以上三種使用 Flask Blueprint 的程式碼組織方式，開發者可以根據專案需求靈活選擇或混合應用。在實際應用中，專案可能需要更細緻的組織結構，此時可以將多種組織方式結合起來，以便更好地滿足需求。</p><p>例如，我們可以根據應用程式的功能和資源類型同時劃分藍圖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">myproject/<br>    ├── auth/<br>    │   ├── __init__.py<br>    │   ├── views.py<br>    ├── admin/<br>    │   ├── posts/<br>    │   │   ├── __init__.py<br>    │   │   ├── views.py<br>    │   ├── images/<br>    │   │   ├── __init__.py<br>    │   │   ├── views.py<br>    ├── user/<br>    │   ├── posts/<br>    │   │   ├── __init__.py<br>    │   │   ├── views.py<br>    │   ├── comments/<br>    │   │   ├── __init__.py<br>    │   │   ├── views.py<br>    ├── templates/<br>    │   ├── auth/<br>    │   │   ├── login.html<br>    │   │   ├── register.html<br>    │   ├── admin/<br>    │   │   ├── posts/<br>    │   │   │   ├── manage_posts.html<br>    │   │   ├── images/<br>    │   │   │   ├── manage_images.html<br>    │   ├── user/<br>    │   │   ├── posts/<br>    │   │   │   ├── list.html<br>    │   │   │   ├── detail.html<br>    │   │   ├── comments/<br>    │   │   │   ├── list.html<br>    │   │   │   ├── new_comment.html<br>    └── app.py<br></code></pre></td></tr></table></figure><p>在這個範例中，我們同時根據功能（身份驗證、管理員、使用者）和資源類型（文章、圖片、評論）劃分藍圖。這樣可以使程式碼更具模組化，便於維護和擴展。同時，不同角色的功能和權限也得到了清晰的區分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flask-Blueprint-組織程式碼的幾種方式&quot;&gt;&lt;a href=&quot;#Flask-Blueprint-組織程式碼的幾種方式&quot; class=&quot;headerlink&quot; title=&quot;Flask Blueprint 組織程式碼的幾種方式&quot;&gt;&lt;/a&gt;Flask Bl</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="Flask 教學" scheme="https://luka.tw/categories/Python/Flask-%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Flask 教學 】Flask Factory 介紹</title>
    <link href="https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/04-flask-factory-143c24814535/"/>
    <id>https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/04-flask-factory-143c24814535/</id>
    <published>2023-02-15T08:16:08.000Z</published>
    <updated>2023-04-25T09:10:45.363Z</updated>
    
    <content type="html"><![CDATA[<p>Flask 是一個輕量的 Python 網頁應用框架，因為它簡單易用而廣受歡迎。其中，Flask Factory 是一個新的概念，可以更加靈活地建立 Flask 應用程式。本文將介紹 Flask Factory 的概念以及如何在 Flask 應用程式中使用它。</p><h3 id="Flask-Factory-是什麼？"><a href="#Flask-Factory-是什麼？" class="headerlink" title="Flask Factory 是什麼？"></a>Flask Factory 是什麼？</h3><p>在傳統的 Flask 應用程式中，我們會在一個檔案中建立 Flask 應用程式物件，然後將它與路由和視圖函式一起定義在同一個檔案中。然而，這種方式的維護和擴展性很差。Flask Factory 的概念就是將 Flask 應用程式物件的建立和設定分離出來，以便更靈活地管理 Flask 應用程式。</p><p>Flask Factory 通常會分為三個部分：</p><ol><li>工廠函式：這是建立 Flask 應用程式物件的函式，通常是一個叫做 <code>create_app</code> 的函式。這個函式會負責建立 Flask 應用程式物件、設定 Flask 應用程式以及註冊路由和視圖函式。</li><li>設定：這是 Flask 應用程式的設定，可以使用 Python Class 或字典來定義。</li><li>視圖函式：這些是處理路由的函式，通常是一個或多個藍圖。</li></ol><h3 id="如何在-Flask-中使用工廠？"><a href="#如何在-Flask-中使用工廠？" class="headerlink" title="如何在 Flask 中使用工廠？"></a>如何在 Flask 中使用工廠？</h3><p>以下是一個簡單的 <code>create_app</code> 工廠函式範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>():</span><br>    app = Flask(__name__)<br>    app.config[<span class="hljs-string">&#x27;DEBUG&#x27;</span>] = <span class="hljs-literal">True</span><br><br><span class="hljs-meta">    @app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, World!&#x27;</span><br><br>    <span class="hljs-keyword">return</span> app<br></code></pre></td></tr></table></figure><p>在上面的範例中，<code>create_app</code> 函式建立了一個 Flask 應用程式物件，並定義了一個路由和一個視圖函式。此外，它還設定了 <code>DEBUG</code> 設定選項，以便在偵錯模式下執行應用程式。</p><p>這個工廠函式可以在另一個檔案中被呼叫，並使用以下程式碼啟動應用程式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> myapp <span class="hljs-keyword">import</span> create_app<br><br>app = create_app()<br>app.run()<br></code></pre></td></tr></table></figure><p>在上面的範例中，<code>create_app</code> 函式在另一個名為 <code>myapp</code> 的模組中定義，然後被呼叫以建立 Flask 應用程式物件。然後，<code>run</code> 方法啟動了應用程式。</p><p>除了上面的範例，我們還可以使用工廠函式來建立複雜的 Flask 應用程式。例如，我們可以使用藍圖來組織視圖函式，使用 Flask 插件來擴展應用程式功能，等等。</p><p>以下是一個更複雜的工廠函式範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> myapp.views <span class="hljs-keyword">import</span> main_bp, admin_bp<br><span class="hljs-keyword">from</span> myapp.extensions <span class="hljs-keyword">import</span> db, login_manager<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_app</span>(<span class="hljs-params">config_object</span>):</span><br>    app = Flask(__name__)<br>    app.config.from_object(config_object)<br><br>    db.init_app(app)<br>    login_manager.init_app(app)<br><br>    app.register_blueprint(main_bp)<br>    app.register_blueprint(admin_bp, url_prefix=<span class="hljs-string">&#x27;/admin&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> app<br></code></pre></td></tr></table></figure><p>在上面的範例中，<code>create_app</code> 函式建立了一個 Flask 應用程式物件，並使用 <code>config_object</code> 設定來設定應用程式。它還初始化了一些 Flask 插件，如 <code>db</code> 和 <code>login_manager</code>，並將它們與應用程式關聯起來。最後，它註冊了兩個藍圖 <code>main_bp</code> 和 <code>admin_bp</code>，這些藍圖包含不同的視圖函式。</p><p>這個工廠函式可以在另一個檔案中被呼叫，並使用以下程式碼啟動應用程式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> myapp <span class="hljs-keyword">import</span> create_app<br><span class="hljs-keyword">from</span> myapp.config <span class="hljs-keyword">import</span> ProductionConfig<br><br>app = create_app(ProductionConfig)<br>app.run()<br></code></pre></td></tr></table></figure><p>在上面的範例中，<code>create_app</code> 函式在 <code>myapp</code> 模組中定義，然後使用 <code>ProductionConfig</code> 設定物件建立 Flask 應用程式物件。然後，<code>run</code> 方法啟動了應用程式。</p><p>總結一下，Flask Factory 是一個有用的概念，可以使我們更加靈活地建立和管理 Flask 應用程式。通過將建立 Flask 應用程式物件的過程分離出來，我們可以更輕鬆地進行擴展和維護。如果您還沒有嘗試過 Flask Factory，我們建議您嘗試一下，體驗一下其帶來的好處。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Flask 是一個輕量的 Python 網頁應用框架，因為它簡單易用而廣受歡迎。其中，Flask Factory 是一個新的概念，可以更加靈活地建立 Flask 應用程式。本文將介紹 Flask Factory 的概念以及如何在 Flask 應用程式中使用它。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="Flask 教學" scheme="https://luka.tw/categories/Python/Flask-%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Flask 教學 】Flask SQLAlchemy | Python 與資料庫的橋樑</title>
    <link href="https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/03-relational-database-7e6315178894/"/>
    <id>https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/03-relational-database-7e6315178894/</id>
    <published>2023-02-13T07:00:00.000Z</published>
    <updated>2023-04-25T09:10:45.364Z</updated>
    
    <content type="html"><![CDATA[<p>在本篇文章，我們將介紹 Flask-SQLAlchemy，讓我們能夠在 Python Flask 應用程式中使用 SQLAlchemy 的 ORM 和 Flask-SQLAlchemy 進行資料庫溝通。</p><p>Flask 是一個輕量級的 Python Web 框架，用於建立 Web 應用程式，而 SQLAlchemy 則是一個 Python 庫，提供對關係資料庫的高效和高效能的訪問。</p><p>Flask-SQLAlchemy 是一個用於 Flask 應用程式的擴展程式，簡化了使用 SQLAlchemy 的複雜性，並提供了常見的對象和模式，例如與每個 Web 請求相關聯的會話、模型和引擎，同時不會更改 SQLAlchemy 的工作方式。</p><p>下面我們來看看如何在 Python Flask 應用程式中使用 Flask-SQLAlchemy。</p><h2 id="安裝-Flask-SQLAlchemy"><a href="#安裝-Flask-SQLAlchemy" class="headerlink" title="安裝 Flask-SQLAlchemy"></a>安裝 Flask-SQLAlchemy</h2><p>要使用 Flask-SQLAlchemy，首先需要在計算機上安裝它。可以使用以下命令在終端中安裝 Flask-SQLAlchemy：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pip install Flask-SQLAlchemy<br></code></pre></td></tr></table></figure><h2 id="建立-Flask-應用程式"><a href="#建立-Flask-應用程式" class="headerlink" title="建立 Flask 應用程式"></a>建立 Flask 應用程式</h2><hr><p>在使用 Flask-SQLAlchemy 之前，需要建立一個 Flask 應用程式。可以使用以下程式碼建立一個簡單的 Flask 應用程式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br></code></pre></td></tr></table></figure><h2 id="設定資料庫"><a href="#設定資料庫" class="headerlink" title="設定資料庫"></a>設定資料庫</h2><hr><p>在 Flask-SQLAlchemy 中，可以使用 PostgreSQL、MySQL、SQLite 或 Oracle 等多種資料庫。在本節中，我們將使用 SQLite3 作為資料庫。可以使用以下程式碼設定資料庫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy<br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="hljs-string">&#x27;sqlite:///example.db&#x27;</span><br>db = SQLAlchemy(app)<br></code></pre></td></tr></table></figure><p>上述程式碼將建立一個名為 example.db 的 SQLite3 資料庫。</p><h2 id="建立資料庫模型"><a href="#建立資料庫模型" class="headerlink" title="建立資料庫模型"></a>建立資料庫模型</h2><p>在 Flask-SQLAlchemy 中，資料庫模型由 Python Class定義。以下是一個簡單的範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    name = db.Column(db.String(<span class="hljs-number">80</span>), nullable=<span class="hljs-literal">False</span>)<br>    email = db.Column(db.String(<span class="hljs-number">120</span>), unique=<span class="hljs-literal">True</span>, nullable=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;User %r&gt;&#x27;</span> % self.username<br></code></pre></td></tr></table></figure><p>上述程式碼定義了一個名為 User 的模型，包含三個屬性：id、name 和 email。</p><h2 id="5：建立資料庫表"><a href="#5：建立資料庫表" class="headerlink" title="5：建立資料庫表"></a>5：建立資料庫表</h2><p>在Flask-SQLAlchemy 中，可以使用以下程式碼建立資料庫表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.create_all()<br></code></pre></td></tr></table></figure><p>上述程式碼將根據模型定義建立資料庫表。</p><h2 id="6：添加資料到資料庫"><a href="#6：添加資料到資料庫" class="headerlink" title="6：添加資料到資料庫"></a>6：添加資料到資料庫</h2><p>在 Flask-SQLAlchemy 中，可以使用以下程式碼向資料庫添加資料：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">User</span>(name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;John Doe&#x27;</span>, email<span class="hljs-operator">=</span><span class="hljs-string">&#x27;johndoe@example.com&#x27;</span>)<br>db.session.add(<span class="hljs-keyword">user</span>)<br>db.session.commit()<br></code></pre></td></tr></table></figure><p>上述程式碼將建立一個新的 User 對象，將其添加到資料庫中，並提交更改。</p><h2 id="7：從資料庫檢索資料"><a href="#7：從資料庫檢索資料" class="headerlink" title="7：從資料庫檢索資料"></a>7：從資料庫檢索資料</h2><p>在 Flask-SQLAlchemy 中，可以使用以下程式碼從資料庫檢索資料：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">users <span class="hljs-operator">=</span> User.query.all()<br></code></pre></td></tr></table></figure><p>上述程式碼將檢索資料庫中的所有 User 對象，並將它們作為列表返回。</p><h2 id="8：更新資料庫中的資料"><a href="#8：更新資料庫中的資料" class="headerlink" title="8：更新資料庫中的資料"></a>8：更新資料庫中的資料</h2><p>在 Flask-SQLAlchemy 中，可以使用以下程式碼更新資料庫中的資料：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">user</span> <span class="hljs-operator">=</span> User.query.filter_by(email<span class="hljs-operator">=</span><span class="hljs-string">&#x27;johndoe@example.com&#x27;</span>).<span class="hljs-keyword">first</span>()<br>user.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span><br>db.session.commit()<br></code></pre></td></tr></table></figure><p>上述程式碼將從資料庫中檢索具有指定電子郵件地址的 User 對象，將其名稱更改為 John，然後提交更改。</p><h2 id="9：刪除資料庫中的資料"><a href="#9：刪除資料庫中的資料" class="headerlink" title="9：刪除資料庫中的資料"></a>9：刪除資料庫中的資料</h2><p>在 Flask-SQLAlchemy 中，可以使用以下程式碼從資料庫中刪除資料：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">user</span> <span class="hljs-operator">=</span> User.query.filter_by(email<span class="hljs-operator">=</span><span class="hljs-string">&#x27;johndoe@example.com&#x27;</span>).<span class="hljs-keyword">first</span>()<br>db.session.delete(<span class="hljs-keyword">user</span>)<br>db.session.commit()<br></code></pre></td></tr></table></figure><p>上述程式碼將從資料庫中刪除具有指定電子郵件地址的 User 對象，然後提交更改。</p><h2 id="小節"><a href="#小節" class="headerlink" title="小節"></a>小節</h2><p>綜上所述，本篇教學文章介紹了 Flask-SQLAlchemy 的基本用法，包括建立 Flask 應用程式、設定資料庫、建立資料庫模型、建立資料庫表、添加資料到資料庫、從資料庫檢索資料、更新資料庫中的資料和刪除資料庫中的資料。這些步驟提供了初學者所需的基礎知識，可以用來構建簡單的 Python Flask 應用程式，以及進一步擴展以實現更複雜的資料庫操作。需要注意的是，Flask-SQLAlchemy 需要一定的學習曲線，但一旦掌握了基本概念，就可以輕鬆地使用它來管理資料庫。</p><p>希望本篇教學文章能夠為初學者提供一個良好的起點，幫助他們進入 Flask-SQLAlchemy 的世界，並開始在 Python Flask 應用程式中進行資料庫溝通。</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><p>以下是本次回答所使用的參考資料的標題和連結：</p><ul><li><a href="https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/quickstart/">Flask-SQLAlchemy 快速入門</a> 和 <a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/quickstart/">Flask-SQLAlchemy 快速入門</a>：兩篇 Flask-SQLAlchemy 的快速入門指南，介紹了 Flask-SQLAlchemy 的基本用法，是初學者快速入門 Flask-SQLAlchemy 的好資源。</li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application">如何在 Flask 應用程式中使用 SQLAlchemy 進行資料庫 </a>：這篇教學透過一個小型的學生管理系統展示了如何使用 Flask-SQLAlchemy 擴展來完成基本的資料庫溝通，如連接到資料庫伺服器、建立資料庫表、添加資料、檢索資料、更新資料和刪除資料等操作。</li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-structure-a-large-flask-application-with-flask-blueprints-and-flask-sqlalchemy">如何使用 Flask Blueprints 和 Flask-SQLAlchemy 構建大型 Flask 應用程式的結構</a>：這篇教學詳細介紹了如何使用 Flask 藍圖和 Flask-SQLAlchemy 構建大型 Flask 應用程式的架構。本文提供了範例程式碼和詳細的解釋，是進階學習 Flask-SQLAlchemy 的好資源。</li><li><a href="https://flask-sqlalchemy.palletsprojects.com/">Flask-SQLAlchemy 文件</a>：Flask-SQLAlchemy 的官方文件，提供了完整的 API 參考、常見問題解答和高級主題等內容。無論您是初學者還是經驗豐富的 Python 開發者，都可以在這裡找到所需的資訊。</li><li><a href="https://pythonbasics.org/flask-sqlalchemy/">Flask SQLAlchemy (with Examples)</a>：這是一篇包含範例的教學，介紹了如何使用 Flask-SQLAlchemy 建立和操作資料庫表。本文包含了範例程式碼和詳細的解釋，是初學者快速掌握 Flask-SQLAlchemy 的好資源。</li><li><a href="https://towardsdatascience.com/building-a-crud-app-with-flask-and-sqlalchemy-1d082741bc2b">使用 Flask 和 SQLAlchemy 建立一個基本的 CRUD 應用程式</a>：這篇 </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在本篇文章，我們將介紹 Flask-SQLAlchemy，讓我們能夠在 Python Flask 應用程式中使用 SQLAlchemy 的 ORM 和 Flask-SQLAlchemy 進行資料庫溝通。&lt;/p&gt;
&lt;p&gt;Flask 是一個輕量級的 Python Web 框架，</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="Flask 教學" scheme="https://luka.tw/categories/Python/Flask-%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Flask 教學 】五分鐘學會 Flask 中的 GET, POST, PUT, PATCH, DELETE</title>
    <link href="https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/02-routes-26425c23607b/"/>
    <id>https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/02-routes-26425c23607b/</id>
    <published>2023-02-10T22:27:46.000Z</published>
    <updated>2023-04-25T09:10:45.363Z</updated>
    
    <content type="html"><![CDATA[<p>本文詳細講解如何在 Flask 中使用 HTTP 請求方法，包括 GET、POST、PUT、PATCH 和 DELETE。文章介紹每種請求方法的用途和使用方法，並提供了相應的程式碼範例，使讀者能夠更好地理解如何在 Flask 中使用這些請求方法。本文適合初學者閱讀，可快速了解 Flask 中 HTTP 請求方法的基本使用方法。</p><h2 id="GET-請求"><a href="#GET-請求" class="headerlink" title="GET 請求"></a>GET 請求</h2><p>GET 請求用於從服務器獲取資料。在 Flask 中，使用 GET 請求非常簡單。以下是一個簡單的範例，使用 GET 請求從服務器獲取資料：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/data&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data</span>():</span><br>    data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>&#125;<br>    <span class="hljs-keyword">return</span> jsonify(data)<br></code></pre></td></tr></table></figure><p>在這個範例中，我們使用 Flask 的 <code>@app.route</code> 裝飾器來指定路由，其中 <code>methods=[&#39;GET&#39;]</code> 指定了使用 GET 請求。我們定義了一個 <code>get_data</code> 函數，返回一個包含 <code>name</code> 和 <code>age</code> 屬性的 JSON Response。</p><h2 id="POST-請求"><a href="#POST-請求" class="headerlink" title="POST 請求"></a>POST 請求</h2><p>POST 請求用於向服務器提交資料。在 Flask 中，使用 POST 請求同樣非常簡單。以下是一個範例，使用 POST 請求提交表單資料：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonify<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/data&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post_data</span>():</span><br>    name = request.form[<span class="hljs-string">&#x27;name&#x27;</span>]<br>    age = request.form[<span class="hljs-string">&#x27;age&#x27;</span>]<br>    data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: name, <span class="hljs-string">&#x27;age&#x27;</span>: age&#125;<br>    <span class="hljs-keyword">return</span> jsonify(data)<br></code></pre></td></tr></table></figure><p>在這個範例中，我們同樣使用 <code>@app.route</code> 裝飾器指定路由和請求方法。我們定義了一個 <code>post_data</code> 函數，使用 <code>request.form</code> 獲取提交的表單資料，然後將資料封裝成 JSON Response返回。</p><h2 id="PUT-請求"><a href="#PUT-請求" class="headerlink" title="PUT 請求"></a>PUT 請求</h2><p>PUT 請求用於更新服務器上的資料。在 Flask 中，使用 PUT 請求也很簡單。以下是一個範例，使用 PUT 請求更新一條記錄：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonify<br><br>app = Flask(__name__)<br><br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>&#125;<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/data/&lt;name&gt;&#x27;</span>, methods=[<span class="hljs-string">&#x27;PUT&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put_data</span>(<span class="hljs-params">name</span>):</span><br>    age = request.form[<span class="hljs-string">&#x27;age&#x27;</span>]<br>    data[name] = age<br>    <span class="hljs-keyword">return</span> jsonify(data)<br></code></pre></td></tr></table></figure><p>在這個範例中，我們使用了 URL 參數 <code>&lt;name&gt;</code> 來指定要更新的記錄。我們定義了一個 <code>put_data</code> 函數，使用 <code>request.form</code> 獲取新的年齡資料，並將資料更新到 <code>data</code> 字典中。</p><h2 id="PATCH-請求"><a href="#PATCH-請求" class="headerlink" title="PATCH 請求"></a>PATCH 請求</h2><p>PATCH 請求用於部分更新服務器上的資料。在 Flask 中，使用 PATCH 請求同樣很簡單。以下是一個範例，使用 PATCH 請求部分更新一條記錄：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonify<br><br>app = Flask(__name__)<br><br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>&#125;<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/data/&lt;name&gt;&#x27;</span>, methods=[<span class="hljs-string">&#x27;PATCH&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">patch_data</span>(<span class="hljs-params">name</span>):</span><br>    age = request.form[<span class="hljs-string">&#x27;age&#x27;</span>]<br>    data[name][<span class="hljs-string">&#x27;age&#x27;</span>] = age<br>    <span class="hljs-keyword">return</span> jsonify(data)<br></code></pre></td></tr></table></figure><p>在這個範例中，我們同樣使用 URL 參數 <code>&lt;name&gt;</code> 來指定要更新的記錄。我們定義了一個 <code>patch_data</code> 函數，使用 <code>request.form</code> 獲取新的年齡資料，並將資料部分更新到 <code>data</code> 字典中。</p><h2 id="DELETE-請求"><a href="#DELETE-請求" class="headerlink" title="DELETE 請求"></a>DELETE 請求</h2><p>DELETE 請求用於刪除服務器上的資料。在 Flask 中，使用 DELETE 請求同樣非常簡單。以下是一個範例，使用 DELETE 請求刪除一條記錄：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify<br><br>app = Flask(__name__)<br><br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>&#125;<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/data/&lt;name&gt;&#x27;</span>, methods=[<span class="hljs-string">&#x27;DELETE&#x27;</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete_data</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">del</span> data[name]<br>    <span class="hljs-keyword">return</span> jsonify(data)<br></code></pre></td></tr></table></figure><p>在這個範例中，我們同樣使用 URL 參數 <code>&lt;name&gt;</code> 來指定要刪除的記錄。我們定義了一個 <code>delete_data</code> 函數，使用 Python 的 <code>del</code> 語句從 <code>data</code> 字典中刪除指定的記錄，並將更新後的資料封裝成 JSON Response返回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文詳細講解如何在 Flask 中使用 HTTP 請求方法，包括 GET、POST、PUT、PATCH 和 DELETE。文章介紹每種請求方法的用途和使用方法，並提供了相應的程式碼範例，使讀者能夠更好地理解如何在 Flask 中使用這些請求方法。本文適合初學者閱讀，可快速了</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="Flask 教學" scheme="https://luka.tw/categories/Python/Flask-%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Flask 教學 】Hello, Flask！五分鐘建立你的第一個 Flask 應用</title>
    <link href="https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/01-hello-flask-794c78ea073a/"/>
    <id>https://luka.tw/Python/Flask-%E6%95%99%E5%AD%B8/python-flask/01-hello-flask-794c78ea073a/</id>
    <published>2021-11-28T22:27:46.000Z</published>
    <updated>2023-04-25T09:10:46.189Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/python-flask/01/cover.png"></p><h2 id="輕量型-Web-框架-Flask"><a href="#輕量型-Web-框架-Flask" class="headerlink" title="輕量型 Web 框架 - Flask"></a>輕量型 Web 框架 - Flask</h2><p><img src="/img/python-flask/01/2021-11-30-00-52-40.png"></p><p><a href="https://flask.palletsprojects.com/en/2.0.x/">Flask</a> 是一款 Python 的網頁開發框架。它的特色就是輕巧。Flask 的官方網站用 <a href="https://flask.palletsprojects.com/en/2.0.x/foreword/#what-does-micro-mean">Micro</a> 這個字來說明 Flask 的設計哲學。</p><p>Micro 意味著，一開始什麼都沒有，沒有資料庫，沒有好用的表單工具，Flask 就提供給你一個非常非常精簡的 Web 框架。</p><p>如果你需要資料庫功能，那麼你需要找尋套件，例如：你想要連接 MySQL 的話，需要安裝 Flask-SQLAlchemy 套件，來擴展你的 Flask 應用程式。</p><p>這跟 Python 中另一個主流框架，Django 大相逕庭。然而 Flask 與 Django 的市占率大概 50% vs 50%，非常有趣，意味著各有各的擁護者。</p><p>瞭解了 Flask 的設計哲學後，接下來我們實作的 Hello World 應用程式，便是只有提供網頁功能，並且只有「一個檔案」的迷你專案。</p><h2 id="Hello-Flask！"><a href="#Hello-Flask！" class="headerlink" title="Hello Flask！"></a>Hello Flask！</h2><p>初學程式的時候發現一個奇特的現象，為什麼第一個程式要輸出 <code>Hello World</code> 呢？因為我們第一件事情就是要確保環境能夠正確執行。</p><h3 id="安裝-Flask"><a href="#安裝-Flask" class="headerlink" title="安裝 Flask"></a>安裝 Flask</h3><p>使用 pip 安裝 Flask</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pip install flask<br></code></pre></td></tr></table></figure><h3 id="組織專案結構"><a href="#組織專案結構" class="headerlink" title="組織專案結構"></a>組織專案結構</h3><p>安裝完成之後，我們先建立一個乾淨的資料夾命名為 hello_flask。<br>接著在裡面建立一個新檔案命名為 <code>hello.py</code><br>所以現在我們的專案結構是 hello_flask 資料夾底下，有一個 hello.py 的檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hello_flask<br>└── hello.py<br></code></pre></td></tr></table></figure><p>接著我們編輯 hello.py 的內容，將以下內容撰寫上檔案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(port=<span class="hljs-number">5000</span>)<br><br></code></pre></td></tr></table></figure><h3 id="在本地端運行"><a href="#在本地端運行" class="headerlink" title="在本地端運行"></a>在本地端運行</h3><p>接著下列指令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> FLASK_APP=hello<br>flask run<br></code></pre></td></tr></table></figure><p>就會發現終端機的畫面，Flask Server (伺服器)已經開始在你的本地開發環境，也就是你的電腦上面運轉囉！</p><p><img src="/img/python-flask/01/2021-11-29-07-08-36.png"></p><p>此時我們複製終端機上的顯示的網址 <code>http://127.0.0.1:5000/</code> 到瀏覽器上，打開便會看到 Hello World！。</p><p><img src="/img/python-flask/01/2021-11-30-01-35-56.png"></p><p>先讓程式跑起來，接下來我們才可以嘗試各式各樣的開發。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://flask.palletsprojects.com/en/2.0.x/">Flask 官方網站</a></li><li><a href="https://www.maxlist.xyz/2020/04/30/flask-helloworld/">實作一個簡單的 Flask 入門 | Max行銷誌</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/python-flask/01/cover.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;輕量型-Web-框架-Flask&quot;&gt;&lt;a href=&quot;#輕量型-Web-框架-Flask&quot; class=&quot;headerlink&quot; title=&quot;輕量型 Web 框架</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="Flask 教學" scheme="https://luka.tw/categories/Python/Flask-%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Python 冷知識 】你知道 PyPI 怎麼唸嘛？</title>
    <link href="https://luka.tw/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/python/03-how-to-pronounce-pypi-4a9321660029/"/>
    <id>https://luka.tw/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/python/03-how-to-pronounce-pypi-4a9321660029/</id>
    <published>2021-11-28T18:30:56.000Z</published>
    <updated>2022-11-27T21:26:12.213Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/python/03/cover.png"></p><p>撰寫另一篇文章 <a href="/2021/11/27/python/02-what-is-pypi/">【 Python 教學 】什麼是 PyPI？跟 pip 又有什麼關係呢？</a>的時候，發現 PyPI 的時候，產生了一個疑問，PyPI該怎麼唸？</p><p>可能的答案有：</p><ol><li>拍拍</li><li>批歪批唉</li><li>批批</li><li>拍批埃</li></ol><p>究竟是哪一個，你念對了嘛？答案在下方教學影片：</p><p><a href="https://www.youtube.com/watch?v=I5OUzCAYst8">How to pronounce PyPI (beginner) Anthony explains #020 - YouTube</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/python/03/cover.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;撰寫另一篇文章 &lt;a href=&quot;/2021/11/27/python/02-what-is-pypi/&quot;&gt;【 Python 教學 】什麼是 PyPI？跟 pip 又有什麼關係呢？&lt;/a</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="基礎教學" scheme="https://luka.tw/categories/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Python 教學 】什麼是 PyPI？跟 pip 又有什麼關係呢？</title>
    <link href="https://luka.tw/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/python/02-what-is-pypi-fc0b4fc6ba6b/"/>
    <id>https://luka.tw/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/python/02-what-is-pypi-fc0b4fc6ba6b/</id>
    <published>2021-11-27T15:11:23.000Z</published>
    <updated>2022-11-27T21:26:12.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什麼是-PyPI？"><a href="#什麼是-PyPI？" class="headerlink" title="什麼是 PyPI？"></a>什麼是 PyPI？</h2><p><img src="/img/python/02/cover.png"></p><p>PyPI（英語 Package Index，簡稱PyPI），是 的官方的第三方套件儲存庫。</p><p><img src="/img/python/02/2021-11-28-05-00-54.png"></p><p>如果用生活的例子來比喻，就像 Android 手機，有 google play 可以安裝軟體。iphone 有 app store 來安裝軟體。在這之中 PyPI 就像是 google play 或是 app store.</p><p>在我們使用 pip 安裝套件的時候，下指令 <code>pip install 套件名稱</code> 預設就是從 PyPI 下載套件。</p><h2 id="在-PyPI-上搜尋套件"><a href="#在-PyPI-上搜尋套件" class="headerlink" title="在 PyPI 上搜尋套件"></a>在 PyPI 上搜尋套件</h2><p><a href="https://pypi.org/">官方網站</a></p><p><img src="/img/python/02/2021-11-28-05-00-25.png"></p><p>我們試著搜尋 web 框架 flask 。看到第一個就是搜尋結果，後方的日期是更新的時間。</p><p><img src="/img/python/02/20211128040736.png"></p><p>點擊進去之後，就可以看到 Flask 的介紹，還有貼心的教學， 在指令列輸入 <code>pip install flask</code> 即可安裝。</p><p><img src="/img/python/02/20211128040929.png"></p><h2 id="在-PyPI-上查看簡易介紹"><a href="#在-PyPI-上查看簡易介紹" class="headerlink" title="在 PyPI 上查看簡易介紹"></a>在 PyPI 上查看簡易介紹</h2><p>下方還有簡單的範例，不過因為這些套件是第三方 (Third-Party) 維護，也就是開發套件的人是自主開發的，因此我們需要到各自的官網看詳細教學。</p><p><img src="/img/python/02/20211128041134.png"></p><h2 id="在-PyPI-找到套件的官方網站，查看詳細文件"><a href="#在-PyPI-找到套件的官方網站，查看詳細文件" class="headerlink" title="在 PyPI 找到套件的官方網站，查看詳細文件"></a>在 PyPI 找到套件的官方網站，查看詳細文件</h2><p>所以我們點擊 documentation</p><p><img src="/img/python/02/20211128041405.png"></p><p>就可以進入到 <a href="https://flask.palletsprojects.com/">Flask 的官方網站</a>，最詳盡的文件可以在這邊找到。</p><p><img src="/img/python/02/20211128041528.png"></p><h2 id="PyPI-跟-pip-有什麼關係呢？"><a href="#PyPI-跟-pip-有什麼關係呢？" class="headerlink" title="PyPI 跟 pip 有什麼關係呢？"></a>PyPI 跟 pip 有什麼關係呢？</h2><p>最後我們來回答標題上的第二個問題，PyPI 跟 pip 的關係，剛剛在操作過程已經知道了。<code>pip install 某某套件</code> 預設的官方套件商店就是 PyPI。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今天介紹的是從 PyPI 官方網站搜尋到需要的套件 (Flask)，然後使用指令安裝需要的套件，最後是如何查詢 Flask 的使用方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什麼是-PyPI？&quot;&gt;&lt;a href=&quot;#什麼是-PyPI？&quot; class=&quot;headerlink&quot; title=&quot;什麼是 PyPI？&quot;&gt;&lt;/a&gt;什麼是 PyPI？&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/python/02/cover.png&quot;&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="基礎教學" scheme="https://luka.tw/categories/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Python 資料科學 】書籍推薦</title>
    <link href="https://luka.tw/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/python/01-data-science-book-69b437eb43dc/"/>
    <id>https://luka.tw/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/python/01-data-science-book-69b437eb43dc/</id>
    <published>2021-11-24T22:23:14.000Z</published>
    <updated>2023-04-25T09:01:47.970Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Data-Science-from-Scratch-中文版（第二版）：用-Python-學資料科學"><a href="#Data-Science-from-Scratch-中文版（第二版）：用-Python-學資料科學" class="headerlink" title="Data Science from Scratch 中文版（第二版）：用 Python 學資料科學"></a>Data Science from Scratch 中文版（第二版）：用 Python 學資料科學</h3><p><img src="/img/python/01/2021-11-25-07-53-06.png"></p><p>這本裡面有大量的名詞幫，適合當工具書來查詢，硬啃的話有點累。名詞如下：</p><p>資料視覺化, 線性代數, 統計學, 機率, 假設與推論, 梯度遞減, 取得資料, 處理資料, 機器學習, k最近鄰, 單純貝氏, 簡單線性迴歸, 多元迴歸, 邏輯迴歸, 決策樹, 神經網路, 深度學習, 集群, 自然語言處理, 網路分析, 推薦系統, 資料庫與SQL, MapReduce</p><h3 id="Python資料分析-第二版"><a href="#Python資料分析-第二版" class="headerlink" title="Python資料分析 第二版"></a>Python資料分析 第二版</h3><p><img src="/img/python/01/2021-11-25-07-53-46.png"></p><p>這本是 pandas 的作者寫的書，本書重點在於使用 pandas 與 NumPy 進行資料載入、資料前處理、資料處理、資料視覺化 … 等等的步驟。如果想要學習完整的流程挺推薦。</p><h3 id="Python資料科學學習手冊"><a href="#Python資料科學學習手冊" class="headerlink" title="Python資料科學學習手冊"></a>Python資料科學學習手冊</h3><p><img src="/img/python/01/2021-11-26-06-11-45.png"></p><p>本書分為五個章節，從資料科學開始介紹，接著介紹常用的 IPython、NumPy、Pandas 資料處理、Matplotlib 資料視覺化、最後介紹 Sckit-Learn 來學習機器學習。非常完整的介紹資料科學的流程。</p><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://www.pttcc.org/bbs/Book/M.1587341470.A.A26">[分享] 2020 推薦 Python資料科學的書</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Data-Science-from-Scratch-中文版（第二版）：用-Python-學資料科學&quot;&gt;&lt;a href=&quot;#Data-Science-from-Scratch-中文版（第二版）：用-Python-學資料科學&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="基礎教學" scheme="https://luka.tw/categories/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>【 Python 教學 】什麼是 Pass By Assignment？</title>
    <link href="https://luka.tw/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/past/2021-09-21-is-python-call-by-sharing-122a4bf5a956/"/>
    <id>https://luka.tw/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/past/2021-09-21-is-python-call-by-sharing-122a4bf5a956/</id>
    <published>2021-09-21T12:50:00.000Z</published>
    <updated>2023-04-24T03:12:44.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/python/00/2021-11-23-00-20-05.png"></p><p>常見的語言的求值策略(Evaluation strategy)大概離不開這幾個，例如：JavaScript (Call by Value, Call by Sharing)、Java (Call by Value)、C (Call by Value)、C++ (Call by Value, Call by Reference)</p><p>這次使用使用淺顯易懂的語言，並搭配圖片來說明到底 Python 中是 Pass by Value, Pass by Reference, 還是 Pass Sharing？</p><h2 id="用-C-理解-Pass-by-Value"><a href="#用-C-理解-Pass-by-Value" class="headerlink" title="用 C++ 理解 Pass by Value"></a>用 C++ 理解 Pass by Value</h2><p>C++ 是探討 Pass by Value 與 Pass by Reference 的最佳選擇。我們先來理解 Pass by Value。</p><h3 id="Pass-by-Value-Output"><a href="#Pass-by-Value-Output" class="headerlink" title="Pass by Value (Output)"></a>Pass by Value (Output)</h3><p><img src="https://hackmd.io/_uploads/B1EzC7xrY.png"></p><p>執行結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before: number is 7  <br>Before: the num is 7  <br>After: the num is 3  <br>After: number is 7<br></code></pre></td></tr></table></figure><h3 id="Pass-by-Value-Address"><a href="#Pass-by-Value-Address" class="headerlink" title="Pass by Value (Address)"></a>Pass by Value (Address)</h3><p>可以看到函式內部的數並不會受到影響，遵守作用域( Scope)範圍。我們再執行另一個程式，查看記憶體位址的改變。</p><p><img src="https://hackmd.io/_uploads/rJYMRmlHY.png"></p><p>執行結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">The Address of number is 0x7ffd0abe7b74  <br>The Address of num is 0x7ffd0abe7b5c  <br>The Address of num is 0x7ffd0abe7b5c  <br>The Address of number is 0x7ffd0abe7b74<br></code></pre></td></tr></table></figure><p>可以發現 num 的位址遵守作用域 (Scope)，經過這兩個程式之後，可以理解到 Pass by Value 是在呼叫函式的時候，複製一份引數(number)給函式使用。</p><p>Step 1：宣告 number 為 7</p><p><img src="https://hackmd.io/_uploads/H1kNRmxBt.png"></p><p>Step 2：呼叫函式時，複製一份給 number 的值複製一份給 num。</p><p><img src="https://hackmd.io/_uploads/ry1HCXert.png"></p><p>step 3：修改 num 的值時，修改的是複製出來的那一份。因此原本的 number 不受影響。</p><p><img src="https://hackmd.io/_uploads/BJPBCXlBK.png"></p><h2 id="用-C-理解-Pass-by-Reference"><a href="#用-C-理解-Pass-by-Reference" class="headerlink" title="用 C++ 理解 Pass by Reference"></a>用 C++ 理解 Pass by Reference</h2><h3 id="Pass-by-Reference"><a href="#Pass-by-Reference" class="headerlink" title="Pass by Reference"></a>Pass by Reference</h3><p><img src="https://hackmd.io/_uploads/SkHTzExSt.png"></p><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before: number is 7  <br>Before: the num is 7  <br>After: the num is 3  <br>After: number is 3<br></code></pre></td></tr></table></figure><h3 id="Pass-by-Reference-Address"><a href="#Pass-by-Reference-Address" class="headerlink" title="Pass by Reference (Address)"></a>Pass by Reference (Address)</h3><p>跟剛剛不同的是，因為 Pass by Reference 傳的是參照，也就是地址，所以裡外等同於是一個變數。接著我們一樣把記憶體位址印出來。看看是不是真的是同樣的記憶體位址。</p><p><img src="https://hackmd.io/_uploads/BkjpfExSY.png"></p><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">The Address of number is 0x7ffd45470b64  <br>The Address of num is 0x7ffd45470b64  <br>The Address of num is 0x7ffd45470b64  <br>The Address of number is 0x7ffd45470b64<br></code></pre></td></tr></table></figure><p>發現結果如我們推測的，從頭到尾記憶體位址都是 <code>0x7ffd45470b64</code> 。因為我們傳的是記憶體位址嘛。</p><p>Step 1：宣告 number</p><p><img src="https://hackmd.io/_uploads/H1fNm_DrF.jpg"></p><p>Step 2：呼叫 passByReference 時不會複製一份 number 的值，也就是「共用」同一份的值。</p><p><img src="https://hackmd.io/_uploads/H10EQdDHK.jpg"></p><p>Step 3：因為共用一份資料，num 更新時，也更新到了 number。</p><p><img src="https://hackmd.io/_uploads/Skx1XNxrK.png"></p><p>Step 4: 看所以最後得到的結果是 <code>After: number is 3</code> ，因為 number 已經被改變</p><p><img src="https://hackmd.io/_uploads/H1jyQ4lrt.png"></p><h2 id="來看看-Python-是不是-Pass-by-Value"><a href="#來看看-Python-是不是-Pass-by-Value" class="headerlink" title="來看看 Python 是不是 Pass by Value"></a>來看看 Python 是不是 Pass by Value</h2><p>接著我們來看看 Python 是否是 Pass by Value。</p><p><img src="https://hackmd.io/_uploads/ByxlQNxrY.png"></p><p>執行結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before the function starts, the number is 7  <br>Before the function starts, the number is 7  <br>After the function ends, the number is 1  <br>After the function ends, the number is 7<br></code></pre></td></tr></table></figure><p>執行完 function_1 後，發現原本的 number，並<strong>沒有</strong>因為在函式中重新指派而改變成 1，還是維持原本的 7。</p><p>看起來跟 C++ 的 Pass Value 很像，接著我們再做一個實驗，把記憶體位置印出來。</p><p><img src="https://hackmd.io/_uploads/B1deQ4gHK.png"></p><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before the function starts, the id is 4321770416  <br>Before assigning, the num is %d 4321770416  <br>After assigning, the num is %d 4321770224  <br>After the function ends, the id is 4321770416<br></code></pre></td></tr></table></figure><p>可以發現，行為雖然像是 Pass by Value，但是記憶體位址變化的時候，並不是執行 function_1 函式的當下，而是在指派 num = 1 之後。這是為什麼呢？</p><p>Step 1：將 7 指派給變數 number，此時 7 存到記憶體中。</p><p><img src="https://hackmd.io/_uploads/rkDiHODSK.jpg"></p><p>Step 2：呼叫函式 pass_by_value() 的時候，將 7 傳了進去。此時函式並不會複製一份值進去。</p><p><img src="https://hackmd.io/_uploads/rkcJU_vBY.jpg"></p><p>Step 3：當執行到 <code>num=1</code>時， num 是整數型別，是 Imuttable Object 不可變物件，值無法改變，因此會新增一塊記憶體來儲存 num。</p><p><img src="https://hackmd.io/_uploads/rJMlUuwSY.jpg"></p><p>Step 4 : 所以最後印出時，不會是 1，而是 7 ，因為 number 與 num 已經沒有共用記憶體位置</p><p><img src="https://hackmd.io/_uploads/rJcg8_PBF.jpg"></p><p>結論：Python 的 function_1 跟 C++的 Call by Value 最後的結果都有分開的記憶體位址。但是從記憶體位址變化的時機可以看得出來，讓 Python 有此現象的，是 Imuttable Object 不可變的特性，而非 Call by Value。</p><h2 id="來看看-Python-是不是Pass-By-Reference"><a href="#來看看-Python-是不是Pass-By-Reference" class="headerlink" title="來看看 Python 是不是Pass By Reference"></a>來看看 Python 是不是Pass By Reference</h2><p>接著我們來看看 Python 是否是 Pass by Reference。</p><p><img src="https://hackmd.io/_uploads/r1LQ7VlBt.png"></p><p>執行結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">before the function starts, the object is `&#123;‘name’: ‘Leo’, ‘age’: 25&#125;`  <br>before the variable assign, the obj is `&#123;‘name’: ‘Leo’, ‘age’: 25&#125;`  <br>after the variable assign, the obj is `&#123;‘name’: ‘9m88’, ‘age’: 20&#125;`  <br>after the function ends, the object is `&#123;‘name’: ‘9m88’, ‘age’: 20&#125;`<br></code></pre></td></tr></table></figure><p>哇，外面 object 的內容居然被改變了，跟剛剛的 number 行為完全不一樣，這是怎麼回事？難道這是 Call by Reference？ 可是我們沒有傳地址進去呀。</p><p>一樣，我們先把記憶體位址印出來試試看。</p><p><img src="https://hackmd.io/_uploads/rkaQmEeSY.png"></p><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before variable assign, the object id is 4508274560  <br>Before variable assign, the obj id is 4508274560  <br>After variable assign, the obj id is 4508274560  <br>After variable assign, the object id is 4508274560<br></code></pre></td></tr></table></figure><p>記憶體位址完全沒有改變，這是為什麼呢？因為剛剛我們使用字典 (dict) 這種資料型別，是屬於可變物件 (Mutable Object)，內容可以改變</p><h3 id="深入資料型別字典-dict-的記憶體調用"><a href="#深入資料型別字典-dict-的記憶體調用" class="headerlink" title="深入資料型別字典(dict) 的記憶體調用"></a>深入資料型別字典(dict) 的記憶體調用</h3><p>我們來看看這段程式記憶體的調用。這次的圖表將記憶體更精確的分為儲存空間所儲存的「資料 Data」與儲存空間的「地址 Address」。</p><p>因為字典這種物件是 mutable 可變的，代表這種物件的值是可以改變的，所以想要來看看到底是記憶體怎麼儲存，才是可以改變的</p><p>如果不了解 Imuttable 的人可以參考我寫的另外一篇文章。<a href="https://medium.com/starbugs/python-mutable-%E8%88%87-immutable-8ef7804181cd">Python — Mutable vs Immutable</a>。裡面講解了 Python 中可變與不可變的概念。</p><p><img src="https://hackmd.io/_uploads/Hkf7U_DSt.jpg"></p><p>宣告 object 物件的時候，變數 Variable: object，指向一個記憶體位址為 <code>x8</code> 資料為 <code>x7</code>。變數本身不直接儲存資料的，只會儲存資料的記憶體位址。而真正的資料儲存在地址為 <code>x7</code> 資料為 <code>&#123;‘name’: ‘Leo’, ‘age’: 25&#125;</code> 。</p><p><img src="https://hackmd.io/_uploads/HJcQ8OwBF.jpg"></p><p>是呼叫function_2 函式的時候，object 的參照傳進去函式裡面，變數名稱變為 obj 。 變數 obj 將內容的地址，儲存在 x9 記憶體位址，資料為 x7。告訴變數 obj 可以去地址 x7 拿資料，這樣就會找到原本物件內容了。</p><p><img src="https://hackmd.io/_uploads/rJwp8uDBt.jpg"></p><p>接著實際執行 pass_by_reference() 函式，因為之前變數 obj 將資料指向跟變數 dict_object 相同的物件，<strong>所以實際修改到的資料，是原本的資料</strong>。最後印出來的時候發現，原始的物件內容已經被改變。</p><p>回顧一下 function_2 的執行結果，函式內部的改變會改變 object 外部的內容。</p><p>執行結果： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">before the function starts, the object is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;   <br>before the variable assign, the obj is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;   <br>after the variable assign, the obj is &#123;‘name’: ‘9m88’, ‘age’: 20&#125;   <br>after the function ends, the object is &#123;‘name’: ‘9m88’, ‘age’: 20&#125;<br></code></pre></td></tr></table></figure><h2 id="來看看-Python-是不是-Pass-by-Sharing"><a href="#來看看-Python-是不是-Pass-by-Sharing" class="headerlink" title="來看看 Python 是不是 Pass by Sharing"></a>來看看 Python 是不是 Pass by Sharing</h2><p>接下來我們來看範例 3，將範例 2 稍作改變，來看看會發生什麼事情</p><p><img src="https://hackmd.io/_uploads/HkRuX4xBK.png"></p><p>我們將 function_2() 方法改成 function_3()。並且把將方法的內容改成建立新物件的方式。</p><figure class="highlight plaintext"><figcaption><span>function\_3(obj):</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pythondef">obj = &#123;  <br>  &#x27;name&#x27;: &#x27;Amy&#x27;,  <br>  &#x27;age&#x27;: 50  <br>&#125;<br></code></pre></td></tr></table></figure><p>執行結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">before the function starts, the dict_object is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;<br>before assign, the obj is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;<br>after assign, the obj is &#123;‘name’: ‘Amy’, ‘age’: 50&#125;<br>after the function ends, the dict_object is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;<br></code></pre></td></tr></table></figure><p>輸出結果再度變回跟 function_1 的結果一樣，無法改變外部物件，這是為什麼呢？</p><p>Step 1: 跟 function_2 完全相同。初始化字典物件內容。</p><p><img src="https://hackmd.io/_uploads/B1hPUdvBF.jpg"></p><p>Step 2: 這時就可以看得出來到底發生了什麼事情了，如果是直接使用建立一個新物件的來賦予變數 obj，那麼將不會改變原本變數 dict_obj 的值。</p><p><img src="https://hackmd.io/_uploads/r1M_8_PSK.jpg"></p><p>我們可以得出一個結論，在使用可變物件(Muttable Object)的時候，如果重新指派新的物件給它，它就不會保持共用記憶體，而是建立一個心的物件。</p><h2 id="Python-到底是-Pass-by-Value-Pass-Value-還是-Pass-Sharing-呢？"><a href="#Python-到底是-Pass-by-Value-Pass-Value-還是-Pass-Sharing-呢？" class="headerlink" title="Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？"></a>Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？</h2><h3 id="都不是，Python-是-Pass-by-Assignment！"><a href="#都不是，Python-是-Pass-by-Assignment！" class="headerlink" title="都不是，Python 是 Pass by Assignment！"></a>都不是，Python 是 Pass by Assignment！</h3><p>我覺得最清楚的是這篇 Stack Overflow 的回答，簡單解釋，引數傳的是物件的參照(Call by Object Reference)，但此 Reference 是由 Pass by Value 的方式實作。</p><p>可以歸納出兩個結論：</p><ul><li>如果你傳遞的可變物件 (Mutable Object)，傳遞的是物件的參照(記憶體位址)，所以可變物件的值是可以改變的，你可以因此修改到原始的物件的內容。</li><li>可變物件 (Mutable Object) 有一個例外是你重新指派一個新的物件給他，外部的作用域(Scope)將無法得知你做的事情，所以外部作用域會認舊的物件，而不是新指派的物件。</li><li>如果你用的是不可變物件(Imutable Object)，那麼因為每次指派都會是新的物件，但是物件是在函式作用域內部生成的，所以外部作用域無法得知。就變成了兩個物件</li></ul><p><img src="https://hackmd.io/_uploads/S1Bcm4xBF.png"></p><p><a href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p><p>最後再回到官方文件的定義，確認一下 Python 真的是 Pass by Assignment，打完收工。</p><p><img src="https://hackmd.io/_uploads/BJ3qm4lrF.png"></p><p><a href="https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference">https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/python/00/2021-11-23-00-20-05.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;常見的語言的求值策略(Evaluation strategy)大概離不開這幾個，例如：JavaScript (Call by Value, Call by S</summary>
      
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="基礎教學" scheme="https://luka.tw/categories/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>用 WSL 在 Windows 上打造 Linux 的開發體驗</title>
    <link href="https://luka.tw/uncategorized/past/2020-11-15-wsl-c4fa84a3a027/"/>
    <id>https://luka.tw/uncategorized/past/2020-11-15-wsl-c4fa84a3a027/</id>
    <published>2020-11-15T12:50:00.000Z</published>
    <updated>2022-11-27T21:26:12.213Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hackmd.io/_uploads/ByE01rxBY.jpg"></p><p>延續上一篇，打造舒適的 Windows ＋ Mac 雙系統開發環境，打算用一系列的文章，一一來介紹開發各種環境。<br><a href="https://medium.com/starbugs/%E6%89%93%E9%80%A0%E8%88%92%E9%81%A9%E7%9A%84%E9%9B%99%E7%B3%BB%E7%B5%B1%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83-windows-mac-%E9%9B%99%E5%88%80%E6%B5%81-6127ce8583a"><strong>打造舒適的雙系統開發環境 Windows + Mac 雙刀流</strong></a></p><h2 id="重度-Mac-Linux-開發者，嘗試-Windows-開發"><a href="#重度-Mac-Linux-開發者，嘗試-Windows-開發" class="headerlink" title="重度 Mac / Linux 開發者，嘗試 Windows 開發"></a>重度 Mac / Linux 開發者，嘗試 Windows 開發</h2><p>先來說說我是個怎麼樣的人，我是個 Mac / Linux 重度使用者，學生時期使用 Windows 開發實在雷，光是搞環境平均就要花一個禮拜以上。再換成一台二手的 Macbook 之後就一路大順暢，從此只用 Mac / Linux 環境開發。</p><p>直到最近看到強者我朋友用 Windows 用得滿順的，不僅 Web 這些比較通用的東西跑得順，連 Linux 套件和 Docker 甚至 K8S 都可以順利執行。於是我就買了一台 Windows 電腦，那就<strong>來打造出能夠媲美 Linux 開發環境的舒適 Windows 開發體驗吧！</strong></p><h3 id="對-Window-敬而遠之的時期"><a href="#對-Window-敬而遠之的時期" class="headerlink" title="對 Window 敬而遠之的時期"></a>對 Window 敬而遠之的時期</h3><p>過去幾年我的主力開發環境以 Mac 或是 Linux 為主要開發環境，主要的原因是，有許多 Linux 的套件在 Windows 上不太穩定，安裝時發生的錯誤，10 台有 7 台會發生不一樣的情況。可能是軟體發生問題，也有可能是硬體導致，雖然說最終還是可以找到解決方案，可是每台電腦或是重灌都要重複花費大量時間的時間在處理環境。讓我這個 Windows 使用者毅然決然使用 Macbook 做為開發工具，這一用下去，也用了 7 年以上了。</p><h3 id="長年使用-Mac-的我，為什麼想要使用-Windows-開發？"><a href="#長年使用-Mac-的我，為什麼想要使用-Windows-開發？" class="headerlink" title="長年使用 Mac 的我，為什麼想要使用 Windows 開發？"></a>長年使用 Mac 的我，為什麼想要使用 Windows 開發？</h3><p>第一個原因是，看到強者我朋友 Windows 上跑各種環境跑的很順，滿讓我訝異的，因為以往雷到爆的 Windows，好像突然間不雷了？</p><p>但現在的 Windows 滿穩定的，我觀察了一些現象，在安裝了一些套件之後，沒有發生以前動不動就爆炸，卻又非常難排除的情形。</p><h2 id="Cmder-—-類似-Linux-的開發體驗"><a href="#Cmder-—-類似-Linux-的開發體驗" class="headerlink" title="Cmder — 類似 Linux 的開發體驗"></a>Cmder — 類似 Linux 的開發體驗</h2><p><img src="https://hackmd.io/_uploads/rJbylBxHK.png"></p><p>Cmder 安裝很簡單，去<a href="https://cmder.net/">官方網站</a>下載即可使用，選擇完全安裝的話，可以連 git 一起安裝起來。可以說是懶人最快建置好環境的方式。</p><p><img src="https://hackmd.io/_uploads/HyjgxreBY.png"></p><p>不過由於 Cmder 只是提供一些「類似」Linux 的體驗。並且他是一種「終端機」，所以並不能解鎖好用的 Linux 開發環境。因此接著介紹下一個好冰友 WSL。</p><h2 id="WSL-—-如果想要一勞永逸，選他"><a href="#WSL-—-如果想要一勞永逸，選他" class="headerlink" title="WSL — 如果想要一勞永逸，選他"></a>WSL — 如果想要一勞永逸，選他</h2><p>WSL 讓 Windows 使用者，不必透過虛擬機，就能直接使用 Linux 環境。現在，Windows 變得對 Linux 開發者更友善。</p><p>可以使用 Linux 指令來操作 Windows 系統，令我感到驚豔。以前裝 Linux 套件用一堆奇怪的方法，最後還是裝不好，現在可以直接在 Windows 無縫銜接 Linux，真滴棒！</p><blockquote><p>WSL 讓我們可以在 Windows 上體驗到 Linux 的開發流暢感。</p></blockquote><p>附上 WSL 的架構圖，簡單的說 Linux 的指令會被轉成 NTCore 的 system call，來達到期待的效果。例如：ls 可以列出檔案，</p><p><img src="https://hackmd.io/_uploads/HJEWlBxrY.png"></p><p>ps: 想要深入了解 WSL 原理請看這篇 ：<a href="https://hackmd.io/@billsun/Bkh8oAmGX?type=view">WSL 原理介紹</a></p><h3 id="WSL-的安裝"><a href="#WSL-的安裝" class="headerlink" title="WSL 的安裝"></a>WSL 的安裝</h3><p>按照下面網頁逐一步驟安裝即可，下面連結中有幾個步驟，依序跑完，即可安裝完成。建議不要參加實驗計畫當白老鼠，跑幾個</p><p>如果沒有加入微軟的實驗計畫，那下面連結中有幾個步驟，依序跑完，即可安裝完成。我自己是沒有參加實驗計畫當白老鼠，指令貼一貼比較省事。</p><p>參考連結：<a href="https://docs.microsoft.com/zh-tw/windows/wsl/install-win10">在 Windows 10 上安裝適用於 Linux 的 Windows 子系統 (WSL)</a></p><h2 id="有了-WSL-之後，來個終端機吧！"><a href="#有了-WSL-之後，來個終端機吧！" class="headerlink" title="有了 WSL 之後，來個終端機吧！"></a>有了 WSL 之後，來個終端機吧！</h2><p>安裝好 WSL 以後，你就可以在 Windows 上面使用 Linux 指令，該怎麼使用終端機呢？</p><p>打開終端機，輸入 wsl 即會進入 WSL 的環境，並且會將路徑綁定到 Windows 的檔案系統上。下面使用的終端機為 Windows Terminal。</p><p><img src="https://hackmd.io/_uploads/H1y7xHlBt.png"></p><h2 id="Terminal-終端機的選擇"><a href="#Terminal-終端機的選擇" class="headerlink" title="Terminal 終端機的選擇"></a>Terminal 終端機的選擇</h2><p>終端機有幾個選擇，如果你是 Windows 慣用的使用者，你可使用 Cmder 來開啟 WSL，因為你已經習慣了 Cmder 帶來的整合度與習慣。Cmder 也滿漂亮的，只是有些地方，還是需要設定和調教，才能符合自己的使用習慣，例如：$ 的取代 … 等等瑣碎的小事。</p><p><img src="https://hackmd.io/_uploads/SJxNgHgBt.png"></p><p>如果你是輕量使用者 ，對終端機不是很熟悉，可以用用看 Windows Terminal。微軟推出了一款 Terminal，簡單素雅的頁面，可以輕鬆切換 Powershell 與 WSL 環境，好像也有很多主題可以客製，算是一個簡單好上手的組合。</p><p><img src="https://hackmd.io/_uploads/BkU4lHlrK.png"></p><p>順帶一提，來看看 Powershell 原始的終端機有多恐怖！！藍色的底，加上進入 WSL 的藍色字體，根本是眼睛殺手，哎呀～我的眼睛業障重！</p><p><img src="https://hackmd.io/_uploads/SyMLereHK.png"></p><p>最後一個選項是使用 VS Code 來整合 WSL，方便大家開發的時候順便使用 VSCode 直接下指令。我覺得這也不失為一個理想的開發環境解決方案。</p><p><img src="https://hackmd.io/_uploads/r1tIereBY.png"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>讓 Windows 上也可以擁有舒適的開發環境是突破自己舒適圈的一小步，現在微軟越來越邁向開源，給他一次機會，雖然因為 Windows 的更新非常的奇葩，你不更新還要給你強制更新，根本使用者體驗殺手，這個情形讓我不會想要轉移主要開發環境過去，但，現在 Windows 是否已經是一個「還可以」的開發環境了呢？我覺得是 ok 的。</p><p>希望這篇有幫助到 Windows 使用者的你😃</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ByE01rxBY.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;延續上一篇，打造舒適的 Windows ＋ Mac 雙系統開發環境，打算用一系列的文章，一一來介紹開發各種環境。&lt;br&gt;&lt;a href=&quot;https://</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ArgoCD — 透過 ArgoCD 認識 GitOps</title>
    <link href="https://luka.tw/uncategorized/past/2020-09-21-introduction-to-gitops-via-argocd-b27fce67e4f9/"/>
    <id>https://luka.tw/uncategorized/past/2020-09-21-introduction-to-gitops-via-argocd-b27fce67e4f9/</id>
    <published>2020-09-21T12:50:00.000Z</published>
    <updated>2022-11-27T21:26:12.213Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hackmd.io/_uploads/ryOEr7lrt.png"></p><h3 id="什麼是-GitOps"><a href="#什麼是-GitOps" class="headerlink" title="什麼是 GitOps ?"></a>什麼是 GitOps ?</h3><p>兩年前初次聽到 GitOps 的時候，我想說是不是只要 Git tag 觸發一些部屬相關的事情，像是下了某個 tag，就會觸發某 Ansible 的工作，部屬某一台伺服器。很遺憾，完全不是我想的那樣。</p><p>在最近實際將 GitOps 整合進開發流程的過程中，深入研究了一下 GitOps。對 GitOps 有了多一點的了解，趁這個機會來跟大家分享一下。</p><p>GitOps 是 Weaveworks 提出的一種持續交付(CD)的概念，透過 Git 來聲明基礎設施(infrastructure)希望的狀態。什麼是聲明基礎設施希望的狀態？</p><h3 id="從聲明基礎設施希望的狀態談到-K8S"><a href="#從聲明基礎設施希望的狀態談到-K8S" class="headerlink" title="從聲明基礎設施希望的狀態談到 K8S"></a>從聲明基礎設施希望的狀態談到 K8S</h3><p>說到聲明希望的狀態，這就要來了解一下屬於 Cloud Native 體系的 Kubernetes 了。</p><p>因為 Kubernetes 是使用 yaml 檔來建立或是修改所擁有的 K8S 元件。例如你想把某個服務擴展從 3 個 pod 擴展到 5 個 pod。那麼你就會修改 yaml 檔裡面的數字。並使用 kubectl 來應用 yaml 檔案至所對應的 K8S 集群。</p><p>簡單說就是 yaml 等於你目前的 K8S 系統狀態。歡迎來到 yaml 的世界！</p><h3 id="GitOps-解決了哪些痛點？"><a href="#GitOps-解決了哪些痛點？" class="headerlink" title="GitOps 解決了哪些痛點？"></a>GitOps 解決了哪些痛點？</h3><p>當我們想要對 K8S 集群做出改變的時候，我們可以做什麼事情？可以直接下 kubectl apply 直接對 K8S 集群進行修改。可是這樣就出現了一個問題，當有許多人都想要對同一個 K8S 進行修改的時候。A 怎麼知道 B 做了什麼修改？如果 B 修改過後，A 並不知道 B 修改了什麼，也進行了一次修改。那麼很有造成系統全面癱瘓。</p><p>Kubernetes 就像一個終極兵器，你可以讓他輕鬆的做到你想做的事情，例如：在幾分鐘內長出具有負載均衡能力的服務。但是也因此如果操作不當，後果會比傳統架構還要嚴重很多。</p><p>這就是 GitOps 出現的原因！</p><h3 id="GitOps-的原則"><a href="#GitOps-的原則" class="headerlink" title="GitOps 的原則"></a>GitOps 的原則</h3><p><img src="https://hackmd.io/_uploads/HJMBH7grt.png"></p><p>Weaveworks 提出 GitOps 的概念，並使用 Flux (不是前端的Flux) 來實作之。其中有幾個比較重要的原則：</p><ol><li><p>整個系統必須是聲名式的</p></li><li><p>希望的狀態必須用 Git 做版控</p></li><li><p>在 Git 中獲准(appoved)的改變可以自動應用到系統上</p></li><li><p>軟體代理(Agent)必須確保系統正確性，如果不正確的話需要有警報通知使用者。</p></li></ol><p>核心觀念其實就是讓你的系統具有「可觀測性」，你可以看到系統目前的狀態。並將所有對 K8S 做的操作，都透過 Git 來操作，這樣的話所有的操作過程都會是一個一個的 Commit。</p><p>下圖左邊是希望的狀態，也就是 Git 中定義的狀態。而實際的狀態，則是右邊。</p><p><img src="https://hackmd.io/_uploads/r1bzO7xBY.png"></p><p>source: <a href="https://github.com/weaveworks/awesome-gitops">https://github.com/weaveworks/awesome-gitops</a></p><p>如果我們使用的是 ArgoCD 可以輕鬆看到希望狀態與實際狀態的不同。</p><h3 id="用-Argo-CD-來了解-GitOps"><a href="#用-Argo-CD-來了解-GitOps" class="headerlink" title="用 Argo CD 來了解 GitOps"></a>用 Argo CD 來了解 GitOps</h3><p><img src="https://hackmd.io/_uploads/H15kcmlHt.png"></p><p>ArogCD 是一款 GitOps 的實現。我們來看看上述說的 GitOps 原則到底是怎麼回事。</p><p><img src="https://hackmd.io/_uploads/SyoSdXlrF.png"></p><p>這是 Argo CD 的圖案，一支外太空章魚(還是什麼生物？)，他提供了強大的觀測介面。可以很好的觀測目前 Kubernetes 集群的狀態。</p><p><img src="https://hackmd.io/_uploads/Sy17qQeSY.png"></p><p>來動手做做看！做一個小改變</p><p><img src="https://hackmd.io/_uploads/S1SZqmeHt.png"></p><p>Argo CD 顯示 Out of sync</p><p><img src="https://hackmd.io/_uploads/HyUg5mlBK.png"></p><p>透過 ArgoCD 可以看到到底對 K8S 集群做了哪些改變。</p><p><img src="https://hackmd.io/_uploads/Hy6ij7gSt.png"></p><p>手動按下 Sync</p><p><img src="https://hackmd.io/_uploads/ByYTjmerY.png"></p><p>看看到底發生了什麼事</p><p><img src="https://hackmd.io/_uploads/Bke0jmxBF.png"></p><p>並且部屬也有版控，萬一不幸弄壞，也可以即時回到上一版本。</p><p><img src="https://hackmd.io/_uploads/ByD0jmgrY.png"></p><p>用起來是不是很輕鬆寫意！</p><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>GitOps 提供 K8S 集群良好可觀測性，並且把開發或是運維對集群的操作記錄在 Git 中，讓任何人可以清楚看到集群做了哪些改變。並且提供了單一的出口，讓開發者和運惟人員不會私自的對集群改變。萬一被改變了，也提供了警報功能來通知主要運維人員。這樣的方式對於 K8S 日常維護來說，無疑是提供了一個非常實用且可靠的方案。</p><h3 id="同場加映"><a href="#同場加映" class="headerlink" title="同場加映"></a>同場加映</h3><p>2021/5/11 update，本篇是 ArgoCD 入門，如果想要看看 ArgoCD 進階運用，請參閱小城老師的文章：</p><ul><li><a href="(https://medium.com/starbugs/a837f9392298)"><strong>Argo CD ApplicationSet Controller: 世界為我而轉動！</strong></a></li></ul><p><em>新推出的 Argo CD ApplicationSet Controller 讓使用者在單個 YAML 檔案內像是寫 For Loop 程式，隨需求一次性地建立大量的 Application CRD，就讓我們使用實際範例來看它如何解放…</em>medium.com]</p><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://www.weave.works/technologies/gitops/">Guide To GitOps</a></li><li><a href="https://www.hwchiu.com/gitops.html">淺談 GitOps 的概念</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ryOEr7lrt.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什麼是-GitOps&quot;&gt;&lt;a href=&quot;#什麼是-GitOps&quot; class=&quot;headerlink&quot; title=&quot;什麼是 GitOps ?</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>從 Github 開源指南｜學習如何貢獻開源專案</title>
    <link href="https://luka.tw/uncategorized/past/2020-08-05-introduction-to-open-source-guild-75881cc9ea41/"/>
    <id>https://luka.tw/uncategorized/past/2020-08-05-introduction-to-open-source-guild-75881cc9ea41/</id>
    <published>2020-08-15T12:50:00.000Z</published>
    <updated>2022-11-27T21:26:12.213Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/7872/0*8Mqb8j7gMZ3_R-UI" alt="Photo by [Tim Mossholder](https://unsplash.com/@timmossholder) on [Unsplash](https://unsplash.com)"></p><p>本週我們來讀一下「如何為開源做貢獻」。這份文件是 Github 的 Open Source Guide 開源指南，約莫兩年前剛出的時候全部是英文版的，已經三年了，拖到現在才讀（汗）。</p><blockquote><p> （這篇是閱讀開源指南的筆記，原創內容偏少，原文在下方連結）<br><a href="https://opensource.guide/zh-hant/how-to-contribute/"><strong>如何為開源做貢獻？</strong><br><em>透過為開源貢獻力量，能從中學習、幫助他人並且從中累積相關技能的經驗 - 任何你能想像得到的技能。 為什麼會有人為開源做出貢獻？有數不清的原因！…</em>opensource.guide</a></p></blockquote><p>是 Github 7000 顆星星的開源專案<br><a href="https://github.com/github/opensource.guide"><strong>github/opensource.guide</strong><br><em>Open Source Guides ( https://opensource.guide/) are a collection of resources for individuals, communities, and…</em>github.com</a></p><h2 id="為何要貢獻開源專案？"><a href="#為何要貢獻開源專案？" class="headerlink" title="為何要貢獻開源專案？"></a><strong>為何要貢獻開源專案？</strong></h2><blockquote><p> 原文寫的很好，我用我的話說出來。</p></blockquote><h3 id="1-打磨你的專業技能"><a href="#1-打磨你的專業技能" class="headerlink" title="1. 打磨你的專業技能"></a>1. 打磨你的專業技能</h3><p>專案中包含了撰寫程式碼、平面設計、使用者體驗設計、撰寫文章 … 等等的工作。只要你想，你就可以在開源專案中找到你的位置。</p><h3 id="2-認識與你有相似興趣的人"><a href="#2-認識與你有相似興趣的人" class="headerlink" title="2. 認識與你有相似興趣的人"></a>2. 認識與你有相似興趣的人</h3><p>我覺得這真的滿重要，在現實生活中要找到相同興趣的人就很困難了，但是透過貢獻開源，你可以無遠弗屆的認識世界各地與你有相似興趣的人。</p><h3 id="3-鍛鍊溝通能力"><a href="#3-鍛鍊溝通能力" class="headerlink" title="3. 鍛鍊溝通能力"></a>3. 鍛鍊溝通能力</h3><p>因為開源專案是一個「共同協做」的專案。你需要向他人解釋自己是用什麼方法實作，也會需要其他人的幫助。</p><h3 id="4-建立名聲"><a href="#4-建立名聲" class="headerlink" title="4. 建立名聲"></a>4. 建立名聲</h3><p>你在開源專案中實作的成果一切都是看的到的，這也意味開源專案是一個能好好火力展示的地方。</p><h3 id="5-學習人際關係的能力"><a href="#5-學習人際關係的能力" class="headerlink" title="5. 學習人際關係的能力"></a>5. 學習人際關係的能力</h3><p>開源為練習領導及管理的能力提供了很好的機會。例如如何解決衝突、組織團隊以及如何為工作的優先順序排列。</p><blockquote><p> 小訣竅：走進開源專案，就像你走進一群陌生人中，想要嘗試融入。這群人討論的非常深入了，你突然打岔肯定會讓人覺得奇怪。<br> 與其盲目地在社群中拋出你自己的看法，不如先觀察一下社群的氛圍後再提出，這樣你的想法被注意到的機會才會增加。</p></blockquote><h2 id="找尋專案開始貢獻"><a href="#找尋專案開始貢獻" class="headerlink" title="找尋專案開始貢獻"></a>找尋專案開始貢獻</h2><p>如果你還未貢獻任何一個開源專案的話，可以想想，你能夠為開源專案做些什麼？</p><p>可以從你有使用過的開源專案開始著手，跟你比較有關係的開源專案，或是你比較感興趣的開源專案，你才會積極的參加。</p><p>平均一個專案有 28% 的貢獻是隨意且偶然的，像是 Readme、改錯字、失效連結 … 等等的小地方。</p><h2 id="找到專案時，先確保專案是否接受貢獻"><a href="#找到專案時，先確保專案是否接受貢獻" class="headerlink" title="找到專案時，先確保專案是否接受貢獻"></a><strong>找到專案時，先確保專案是否接受貢獻</strong></h2><p>可以從幾個地方，看出專案是否活躍，樂於接受貢獻：</p><p>從 Master 分支上看看觀察</p><ul><li><p>最近一次的 Commit 是什麼時候？</p></li><li><p>Commit 的次數頻繁嘛？</p></li><li><p>專案目前有多少貢獻者？</p></li></ul><p>從 Issue 觀察</p><ul><li><p>目前有多少個 issue</p></li><li><p>維護者回覆 issue 是否迅速</p></li><li><p>是否有討論熱絡的 issue</p></li><li><p>issue 是否已經大量累積</p></li><li><p>最近 close 的 issue 是多久以前</p></li></ul><p>從 PR 觀察</p><ul><li><p>有多少處於進行中的 PR</p></li><li><p>提交 PR 後維護者回覆是否迅速</p></li><li><p>最近有多少 PR 被 Merge</p></li></ul><p>觀察專案的友善程度</p><ul><li><p>維護者的回應是否有幫助</p></li><li><p>討論過程是否親切</p></li><li><p>會不會審查 PR</p></li></ul><h2 id="如何將成果貢獻至開源專案"><a href="#如何將成果貢獻至開源專案" class="headerlink" title="如何將成果貢獻至開源專案"></a>如何將成果貢獻至開源專案</h2><p>最重要的是「有效的溝通」，把握幾個要點：</p><h3 id="1-交代來龍去脈"><a href="#1-交代來龍去脈" class="headerlink" title="1. 交代來龍去脈"></a>1. 交代來龍去脈</h3><p>讓他人快速的理解。如果是 Bug 交代清楚你想做的事情是什麼，你當實作了哪些步驟，以便重現錯誤。如果你想要發起一個新的想法，你要解釋為什麼你要這樣做，為什麼你覺得這樣會對專案有幫助。</p><h3 id="2-做好準備工作"><a href="#2-做好準備工作" class="headerlink" title="2. 做好準備工作"></a>2. 做好準備工作</h3><p>在尋求幫助之前，先確保你看過文件、相關 Issue 的討論，當你表達出強烈的意願時，人們會很樂意幫助你的。</p><h3 id="3-溝通時力求精簡明瞭"><a href="#3-溝通時力求精簡明瞭" class="headerlink" title="3. 溝通時力求精簡明瞭"></a>3. 溝通時力求精簡明瞭</h3><p>開源專案每次提交都是需要他人檢閱的，如果你能夠精準的表達你的看法，那麼你得到別人幫助的機會就會大幅提昇。</p><h3 id="4-大膽的提問（但是要有耐心！）"><a href="#4-大膽的提問（但是要有耐心！）" class="headerlink" title="4. 大膽的提問（但是要有耐心！）"></a><strong>4. 大膽的提問（但是要有耐心！）</strong></h3><p>每個人都有新手的時候，不要怕提問。需要注意的是長期維護的人不一定熟悉專案的每一個部分。協作時表現出你的耐心，你會得到相同回報。</p><h3 id="5-尊重社群的決定"><a href="#5-尊重社群的決定" class="headerlink" title="5. 尊重社群的決定"></a>5. 尊重社群的決定</h3><p>有時候你的看法跟社群的看法不一定相同。他們可能不接受你的建議。可能社群最後不接納你的建議。這時你可以試試看討論出折衷方案，或者將專案 fork 另起爐灶。</p><h2 id="提交之後"><a href="#提交之後" class="headerlink" title="提交之後"></a>提交之後</h2><h3 id="😭有可能沒有人理你"><a href="#😭有可能沒有人理你" class="headerlink" title="😭有可能沒有人理你"></a>😭有可能沒有人理你</h3><p>因為大家都很忙，尤其是熱門的開源專案。Issue 很多，維護者的人手不夠，此時就先耐心的等待。</p><blockquote><p> <em>千萬不要私下聯絡，在開源專案中，一切的溝通都應該是公開的。</em></p></blockquote><h3 id="🚧有人希望你修改你的貢獻"><a href="#🚧有人希望你修改你的貢獻" class="headerlink" title="🚧有人希望你修改你的貢獻"></a>🚧有人希望你修改你的貢獻</h3><p>這是好的開始，溝通、改進直到符合維護者得期待。</p><h3 id="👎你的貢獻沒有被採納"><a href="#👎你的貢獻沒有被採納" class="headerlink" title="👎你的貢獻沒有被採納"></a>👎你的貢獻沒有被採納</h3><p>你的工作最後沒有被採納，這時你可以問問維護者，為什麼沒有被採納。需要注意的是別花時間在爭論上，這會讓你樹立更多敵人。</p><h3 id="🎉-你的貢獻被接受。"><a href="#🎉-你的貢獻被接受。" class="headerlink" title="🎉 你的貢獻被接受。"></a>🎉 你的貢獻被接受。</h3><p>太棒了！你完成了一次開源貢獻！</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ul><li><a href="https://opensource.guide/zh-hant/starting-a-project/"><strong>發起一個開源專案</strong></a></li><li><a href="https://opensource.guide/zh-hant/best-practices/"><strong>維護者最佳實踐</strong></a></li><li><a href="https://opensource.guide/zh-hant/leadership-and-governance/"><strong>領導與治理</strong></a></li><li><a href="https://opensource.guide/zh-hant/code-of-conduct/"><strong>建立一套行為準則</strong></a></li><li><a href="https://opensource.guide/zh-hant/finding-users/"><strong>找尋專案的使用者</strong></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/7872/0*8Mqb8j7gMZ3_R-UI&quot; alt=&quot;Photo by [Tim Mossholder](https://unsplash.com/@timmossholder</summary>
      
    
    
    
    
    <category term="Github" scheme="https://luka.tw/tags/Github/"/>
    
    <category term="Open Source" scheme="https://luka.tw/tags/Open-Source/"/>
    
  </entry>
  
  <entry>
    <title>TLDR 命令列神兵｜Linux 入門必裝</title>
    <link href="https://luka.tw/uncategorized/past/2020-07-28-tldr-ec3f4ea68bb3/"/>
    <id>https://luka.tw/uncategorized/past/2020-07-28-tldr-ec3f4ea68bb3/</id>
    <published>2020-07-28T08:01:00.000Z</published>
    <updated>2022-11-27T21:26:12.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TL-DR-的意思是：哩供蝦？講重點好嘛？"><a href="#TL-DR-的意思是：哩供蝦？講重點好嘛？" class="headerlink" title="TL;DR 的意思是：哩供蝦？講重點好嘛？"></a>TL;DR 的意思是：哩供蝦？講重點好嘛？</h3><p><img src="https://hackmd.io/_uploads/B1KzfHerK.png"></p><p>TLDR 能夠讓初學程式的新手 ，輕鬆了解命令列工具的各種 Linux 指令，並且自由運用。本篇文章分成幾個兩個部分：</p><ul><li><p>命令列工具 Command line tool 到底是什麼東西？</p></li><li><p>TLDR 是什麼東西？它如何幫助我們快速適應 Linux 命令列工具？</p></li></ul><p>話不多說，我們開始吧。</p><h2 id="命令列工具-Command-line-tool-到底是什麼？"><a href="#命令列工具-Command-line-tool-到底是什麼？" class="headerlink" title="命令列工具 Command line tool 到底是什麼？"></a>命令列工具 Command line tool 到底是什麼？</h2><p>命令列工具的英文是 Command Line Tool。下圖就是常見的命令列工具。那麼他的作用是什麼呢？</p><p><img src="https://hackmd.io/_uploads/Sk2mfrgrK.png"></p><p>這是什麼意思？為什麼要透過下指令的方式讓做事？原因是：</p><blockquote><p> 用命令列工具的來做事情非常有效率。</p></blockquote><p>試想如果你想要安裝一個知名影音播放軟體 VLC，你會做些什麼事情？首先你會 Google，開幾個網頁，看看哪個載點比較值得信賴，然後選一個覺得不錯的下載，等到下載完成之後再安裝。</p><p>哪麼換成命令列工具呢，只要下一行指令即可</p><pre><code>brew cask install vlc</code></pre><p>來看看會發生什麼事情？</p><p><img src="https://hackmd.io/_uploads/BJNVGHxHF.png"></p><p>VLC 已經裝好了，終端機顯示 VLC 安裝在 /Applications/VLC.app。接著我們打開 /Application 資料夾，VLC 已經安裝好了。</p><p><img src="https://hackmd.io/_uploads/SyKVGHgBY.png"></p><p>也許你覺得用手動點擊也可以幫你做到同樣的事情，但是當這種有效率的小動作逐步累積的時候，就會造成效率上的極大差異。別人用 15 分鐘做好的事情你可能需要花一個小時。隨著做的事情越複雜效率的差異會越大。</p><blockquote><p>命令列工具那麼好用？ 那到底要怎麼用？<br>tldr 就是告訴我們各種 Linux 指令怎麼用的工具。</p></blockquote><h2 id="TLDR-登場，看看它如何大發神威"><a href="#TLDR-登場，看看它如何大發神威" class="headerlink" title="TLDR 登場，看看它如何大發神威"></a>TLDR 登場，看看它如何大發神威</h2><p>這下子就輪到我們的主角登場啦，TLDR！TLDR 能夠用最簡短的方式告訴你各種指令的用法。</p><p>TL;DR 是 too long; didn’t read 的縮寫，初學 Linux 的時候一堆指令的縮寫有夠難懂，什麼 ls、pwd、mv … 諸如此類的指令。當你不懂的時候怎麼辦？用 TLDR 就對了！</p><p>來示範一下怎麼用，假設我們不知道 ls 指令怎麼使用。想破頭也不知道 ls 指令到底用來幹嘛的？ 輸入 tldr ls 立刻了解 ls 如何使用。</p><p><img src="https://hackmd.io/_uploads/H1eLfSxBK.png"></p><p>從上圖中的第一行就告訴你，ls 的功用是列出目前資料夾的內容。如果你需要更多的用法，可以參照 tldr 幫你精選出來的各種常用指令。<strong>TLDR 絕對不完整，但是很容易上手！</strong></p><p>另一種對比的 Linux 完整文件的指令是 man，在終端機輸入 man ls ，呈現的樣子如下圖，落落長，跟 TLDR 完全相反，保證完整，但要看很久。我們常常只是要用 Linux 指令做一些簡單的事情，所以並不需要看的那麼仔細。</p><p><img src="https://hackmd.io/_uploads/BJkPMBlSY.png"></p><p>再來試試看 pwd，可以很清楚的看到 pwd的功用是印出目前工作的目錄。</p><p><img src="https://hackmd.io/_uploads/B1n9GSgHK.png"></p><p>然後你再輸入一次 pwd，就可以很清楚的知道「顯示出來的內容是目前的工作目錄」</p><p><img src="https://hackmd.io/_uploads/HJzofBeBF.png"></p><h2 id="TLDR-如何安裝？"><a href="#TLDR-如何安裝？" class="headerlink" title="TLDR 如何安裝？"></a>TLDR 如何安裝？</h2><p>既然是新手教學文，最後我們就來講一下怎麼安裝</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g tldr<br></code></pre></td></tr></table></figure><p>一行指令搞定，就是這麼輕鬆寫意。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>TLDR 的出現，讓我除了<a href="http://linux.vbird.org/">鳥哥的Linux 私房菜</a>以外多了一個認識 Linux 指令的管道。更有趣的它是一個開源專案，如果用 tldr 某某指令 找不到結果，你還可以自行貢獻自己的小抄，讓世界上的其他人用得到。對於新手來講是一個滿好入門的工具。</p><p>如果覺得我的文章對你有幫助 ，<a href="https://medium.com/@LukaTW">來 follow 我吧</a>！最近我會常寫文的呦。<br>也別忘了 follow 星巴哥技術週刊，每週推送優質原創文章！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;TL-DR-的意思是：哩供蝦？講重點好嘛？&quot;&gt;&lt;a href=&quot;#TL-DR-的意思是：哩供蝦？講重點好嘛？&quot; class=&quot;headerlink&quot; title=&quot;TL;DR 的意思是：哩供蝦？講重點好嘛？&quot;&gt;&lt;/a&gt;TL;DR 的意思是：哩供蝦？講重點好嘛？&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Kubernetes IDE | Lens 用圖形化介面管理 K8S</title>
    <link href="https://luka.tw/uncategorized/past/2020-06-30-lens-the-ide-for-kubernetes-0628841f91d9/"/>
    <id>https://luka.tw/uncategorized/past/2020-06-30-lens-the-ide-for-kubernetes-0628841f91d9/</id>
    <published>2020-06-30T09:01:00.000Z</published>
    <updated>2022-11-27T21:26:12.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2400/0*P3QeV7d9iPBNeOCr.png" alt="https://k8slens.dev"></p><p>以往我們在管理 Kubernetes 集群的時候，需要大量的命令列操作，需要去四處找尋需要的資訊，例如你想看 Node 的狀態你可能需要在 AWS Console 上面看，如果你用的是 GKE 的話你就需要到的 GCP 的後台上看。你想要進入 Pod 你需要先下 kubectl get pods取得 pod 列表，接著再下 kubectl exec -it pod/xxxpod – bash 進入。</p><p>這些功能現在 Lens 全部幫你整合進去了。它能夠讓你快速的瀏覽你的 K8S 集群狀況，並且即時反應 K8S 集群的狀態讓你可以做相對應的反應。我們就來看看 Lens 有哪些殺手級的功能吧！</p><h2 id="Lens-有哪些殺手級功能"><a href="#Lens-有哪些殺手級功能" class="headerlink" title="Lens 有哪些殺手級功能"></a>Lens 有哪些殺手級功能</h2><h2 id="1-實時監控-pod-的狀態-realtime-monitoring"><a href="#1-實時監控-pod-的狀態-realtime-monitoring" class="headerlink" title="1. 實時監控 pod 的狀態 (realtime monitoring)"></a>1. 實時監控 pod 的狀態 (realtime monitoring)</h2><p>可以實時監控 pod 的狀態，不需要手動刷新，這個功能我覺得滿方便的。一般來說你想要重複獲取 pod 的狀態需要在終端機中輸入 kubectl get pods，用終端機下指令的方式只能知道下指令的「當下的狀態」，如果你想要獲得你想要的狀態，你必須不斷下指令。而現在使用 Lens 你只需要瞄一下螢幕，就可以知道 pod 就緒了沒，因為 Lens 會告訴你最即時的 Pod 狀態。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*ce7US7IAR0EPDvYlQIrhBQ.png" alt="為了不透漏機密資訊我使用 Lens 官方網站的圖片 ([https://k8slens.dev/](https://k8slens.dev/))"></p><h2 id="2-快速查看-Pod-的-CPU-、記憶體用量"><a href="#2-快速查看-Pod-的-CPU-、記憶體用量" class="headerlink" title="2. 快速查看 Pod 的 CPU 、記憶體用量"></a>2. 快速查看 Pod 的 CPU 、記憶體用量</h2><p>我覺得這是令人滿驚艷的功能，Newrelic 針對 K8S 推出的監控工具操作起來都沒有那麼直覺。因此目前的監控方案用 Newrelic 來看吞吐量與 request 的消耗時間，方便做一些效能調校。而觀看 Kubernetes 整體的狀態則是使用 Lens 為主。能夠快速找到想要的資訊並能夠反應實時(realtime)的狀態真的挺重要。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*Jv4voRbrXD7vFogoFwBskg.png" alt="image from [https://k8slens.dev/](https://k8slens.dev/)"></p><h2 id="3-快速觀看-Node-的狀態"><a href="#3-快速觀看-Node-的狀態" class="headerlink" title="3. 快速觀看 Node 的狀態"></a>3. 快速觀看 Node 的狀態</h2><p>Pod 是 Kubernetes 中的最小單位，但最後他還是會跑在某一台實體機器，也就是 Node 上面，所以我們可以快速的看到 Node 的狀態也是很重要的。</p><p>沒錯，Lens 就是那麼的威，可以快速的看到 K8S 中 Node 的 CPU、記憶體用量，還有 Node 上跑了哪些 Pod，運行了哪些資源。</p><p>我覺得根本整合度極高。偏愛用終端機的我，目前也離不開 Lens 的方便。</p><p><img src="https://cdn-images-1.medium.com/max/3340/1*XGv9gmMz73ZKZjw_bEb_ww.png"></p><h2 id="4-Event-列表，能夠即時知道-K8S-集群發生了什麼事"><a href="#4-Event-列表，能夠即時知道-K8S-集群發生了什麼事" class="headerlink" title="4. Event 列表，能夠即時知道 K8S 集群發生了什麼事"></a>4. Event 列表，能夠即時知道 K8S 集群發生了什麼事</h2><p>例如：一個 pod 中的 readiness probe 告訴你：你的 pod 還沒有準備好啦！Lens 就有這個功能，可以即時知道 K8S Cluster 的事件。不然很有可能 Kubernetes 發生了一些事情，但是你沒有察覺。</p><h2 id="5-Pod-gt-Terminal-一鍵搞定"><a href="#5-Pod-gt-Terminal-一鍵搞定" class="headerlink" title="5. Pod -&gt; Terminal 一鍵搞定"></a>5. Pod -&gt; Terminal 一鍵搞定</h2><p>平常要進入某 Pod 的時候先 k get pods，然後複製貼上 pod 的名稱，輸入 k exec -it pod/your-pod-name – /bin/bash 每次做真的有點煩。Lens 直接列出所有 Pod，你只需要點選有問題的 Pod，或是你想要進去的 Pod，點擊終端機鍵，即可連進 Pod 裡面。真～是～太～方～便～啦～！</p><p><img src="https://cdn-images-1.medium.com/max/2790/1*yGkNYU4kdqJ85C7u-Aq0Og.png"></p><h2 id="為什麼-Kubernetes-能夠有一款-IDE？"><a href="#為什麼-Kubernetes-能夠有一款-IDE？" class="headerlink" title="為什麼 Kubernetes 能夠有一款 IDE？"></a>為什麼 Kubernetes 能夠有一款 IDE？</h2><p>最後來聊一聊為什麼 Kubernetes 能夠出一款 IDE？一般來說 IDE 是基於語言設計出的 IDE，例如：java 有 Eclipse，c# 有 visual studio，Python 有 Pycharm，PHP 有 Phpstorm… 等等。</p><p>這些以語言為基礎的 IDE 可以提供語言為基礎的一些好用方法。例如方法的自動完成、原始碼的快速查找，或是提取方法、提取參數 … 等等重構的功能。基於每個語言的特性，IDE 提供不同的特性。</p><p>Kubernetes 的 IDE 是怎麼回事呢？各家提供雲服務的平台紛紛推出相對應 K8S 的服務。例如：Google 有 GKE，AWS 有 EKS，或是也可以自行架設 Kubernetes 集群。</p><p>這些 Kubernetes 服務都遵循著相同的 Kubernetes 規範，聽起來好像有點繞，如果不是因為有 Kubernetes 這樣明確的規範，就不可能有 IDE 產生。</p><p>例如：Google 的雲端平台 GCP 上如果你想要開機器，跟 AWS 平台上你想要開機器，那麼你是無法用一套 IDE 來監控或是控制兩者的機器狀態的。因為 Google 和 AWS 機器呼叫的規格各自有各自的定義，無法共通。</p><p>而 Kubernetes 大家都是透過 kubectl 來跟 Kubenetes Control Panel 溝通。Kubenetes 中的元件，例如：Pod、Service、Deployment … 等等，在各家雲服務商也都是遵照相同規範實作，因此可以使用一款 IDE，就能夠監控各家的 Kubernetes 集群。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a><strong>結語</strong></h2><p>Lens 的出現讓我用最少的力氣就可以快速的看到想看的資訊。而 Newrelic 的方式比較像是以往的 APM 的監控法。跟以前只有機器的時代，多了一層 Kubernetes 多了滿多思考點。另外警報(Alert)又是另一套系統了。如何在問題出現的時候，快速定位問題，在使用者察覺前解決掉，是一個有趣的挑戰。</p><blockquote><p> 最後不免俗的感謝大家觀看，喜歡我的文章請訂閱 Starbugs 星巴哥技術專欄，每週推送原創好文😀😀😀</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2400/0*P3QeV7d9iPBNeOCr.png&quot; alt=&quot;https://k8slens.dev&quot;&gt;&lt;/p&gt;
&lt;p&gt;以往我們在管理 Kubernetes 集群的時候，需要大</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TPM — 套件管理工具 ，讓你的 TMUX 更好用</title>
    <link href="https://luka.tw/uncategorized/past/2020-06-02-tmp-let-your-tmux-better-f3ad7ae8d972/"/>
    <id>https://luka.tw/uncategorized/past/2020-06-02-tmp-let-your-tmux-better-f3ad7ae8d972/</id>
    <published>2020-06-02T11:51:00.000Z</published>
    <updated>2022-11-27T21:26:12.212Z</updated>
    
    <content type="html"><![CDATA[<p>最近因為工作上需要用到開很多個視窗的情景，研究了一下如何把 tmux 變得更具有生產力。</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*wJrJdR3tFO84Tdsd.jpg"></p><h2 id="tmux-是什麼？"><a href="#tmux-是什麼？" class="headerlink" title="tmux 是什麼？"></a>tmux 是什麼？</h2><p><a href="https://github.com/tmux/tmux">tmux</a> 是一個很好用的遠端 session 管理套件，兼具效能與功能性，可以讓你在遠端伺服器中，輕易管理背景執行程式。</p><p>Larry 在 **<a href="https://larrylu.blog/tmux-33a24e595fbc">終端機 session 管理神器 — tmux</a> **文章中介紹了基本的概念、使用方式與經典的使用情景。如果沒有看過的話，請看文章了解一下。<br><a href="https://larrylu.blog/tmux-33a24e595fbc"><strong>終端機 session 管理神器 — tmux</strong><br><em>身為一名開發者對終端機應該不陌生，不管是要執行腳本、ssh 到遠端伺服器都會用到終端機。<br>這邊要介紹給大家一個工具 tmux，tmux 是個 terminal multiplexer，可以讓你的終端機更好用</em>larrylu.blog</a><a href="https://larrylu.blog/tmux-33a24e595fbc">t</a></p><p>不過其實不看也沒什麼關係啦，看我寫得就好<em>。</em></p><h2 id="Hello-tpm"><a href="#Hello-tpm" class="headerlink" title="Hello, tpm"></a>Hello, tpm</h2><p><a href="https://github.com/tmux-plugins/tpm">tpm</a> 是 tmux 的套件管理工具，英文是 Tmux Plugin Manager。tmux 之於 tpm 就如同是 nodejs 之於 npm。是一個在 github 上面有 6100 顆星星的開源專案。</p><p>今天我的重點放在 tpm 的介紹上，如果還沒安裝 tmux，請按照 **<a href="https://larrylu.blog/tmux-33a24e595fbc">終端機 session 管理神器 — tmux</a> **文章中的教學逐步安裝並學習使用方法。</p><p>回過頭來，我們想要用 tpm 來安裝一些好用的套件，先安裝好 tpm。 首先 git clone tpm 至本機。</p><pre><code>git clone [https://github.com/tmux-plugins/tpm](https://github.com/tmux-plugins/tpm) ~/.tmux/plugins/tpm</code></pre><p>接著修改 ~/.tmux.conf 檔案的內容，將下列內容複製貼上至檔案中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># List of plugins</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tpm&#x27;</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tmux-sensible&#x27;</span><br><br><span class="hljs-comment"># Other examples:</span><br><span class="hljs-comment"># set -g @plugin &#x27;github_username/plugin_name&#x27;</span><br><span class="hljs-comment"># set -g @plugin &#x27;git@github.com/user/plugin&#x27;</span><br><span class="hljs-comment"># set -g @plugin &#x27;git@bitbucket.com/user/plugin&#x27;</span><br><br><span class="hljs-comment"># Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)</span><br>run -b <span class="hljs-string">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span><br></code></pre></td></tr></table></figure><p>安裝完成後在終端機中輸入下列指令或是重開終端機即可載入完成。</p><pre><code>tmux source ~/.tmux.conf</code></pre><h2 id="要怎麼使用-tpm-安裝-tmux-套件"><a href="#要怎麼使用-tpm-安裝-tmux-套件" class="headerlink" title="要怎麼使用 tpm 安裝 tmux 套件"></a>要怎麼使用 tpm 安裝 tmux 套件</h2><p>安裝 tpm 套件可能跟你想的不太一樣，直接修改 ~/.tmux.conf 檔案的內容，並且重啟。例如你想要安裝 <a href="https://github.com/tmux-plugins/tmux-copycat">tmux-copycat</a>。</p><pre><code>vim ~/.tmux.conf</code></pre><p>加入這一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tmux-copycat&#x27;</span><br></code></pre></td></tr></table></figure><p>接著，重開 tmux session 或是在 tmux 中輸入 prefix (ctrl+b) + I 即可。</p><h2 id="ctrl-b-有點遠，修改-prefix-為-ctrl-a"><a href="#ctrl-b-有點遠，修改-prefix-為-ctrl-a" class="headerlink" title="ctrl+b 有點遠，修改 prefix 為 ctrl + a"></a>ctrl+b 有點遠，修改 prefix 為 ctrl + a</h2><p>tmux 大部分的指令是由組合鍵 prefix + 某某鍵所構成。 prefix 預設是 ctrl + b，外國鄉民大多是將 prefix 修改成 ctrl + a ，你也可以設成你喜歡的樣子，設定方法很簡單。在 .tmux.conf 中加上以下內容即可將 prefix 變成ctrl + a。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># remap prefix from &#x27;C-b&#x27; to &#x27;C-a&#x27;</span><br>unbind C-b<br>set-option -g prefix C-a<br>bind-key C-a send-prefix<br></code></pre></td></tr></table></figure><h2 id="介紹幾個好用的套件"><a href="#介紹幾個好用的套件" class="headerlink" title="介紹幾個好用的套件"></a>介紹幾個好用的套件</h2><h3 id="tmux-yank"><a href="#tmux-yank" class="headerlink" title="tmux-yank"></a><a href="https://github.com/tmux-plugins/tmux-yank">tmux-yank</a></h3><p>讓你的 tmux 可以用系統的剪貼簿，支援 osx, linux, WSL(Windows Subsystem for Linux) … 等等的環境。</p><h3 id="tmux-pain-control"><a href="#tmux-pain-control" class="headerlink" title="tmux-pain-control"></a><a href="https://github.com/tmux-plugins/tmux-pain-control">tmux-pain-control</a></h3><p>這個套件有三大功能，第一是切割視窗，第二是在視窗中跳躍，第三是縮放視窗大小。</p><h3 id="讓切割視窗變得更加簡單"><a href="#讓切割視窗變得更加簡單" class="headerlink" title="讓切割視窗變得更加簡單"></a>讓切割視窗變得更加簡單</h3><p>這兩個是 tmux 預設的切割視窗快捷鍵</p><ol><li><p>prefix + “：進行<strong>水平</strong>分割</p></li><li><p>prefix + %：進行<strong>垂直</strong>分割</p></li></ol><p>這兩個符號我一直記不起來😭，但是在使用<a href="https://github.com/tmux-plugins/tmux-pain-control">tmux-pain-control</a> 之後：</p><ol><li><p>prefix + |：進行<strong>水平</strong>分割</p></li><li><p>prefix + -：進行<strong>垂直</strong>分割</p></li></ol><p>圖型記憶法，真是太好記了。連續技用起來會有這樣的效果：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*P3MQZDaihxlpHZwBNTvdpQ.gif"></p><h3 id="用-vim-的方向鍵跳轉視窗"><a href="#用-vim-的方向鍵跳轉視窗" class="headerlink" title="用 vim 的方向鍵跳轉視窗"></a>用 vim 的方向鍵跳轉視窗</h3><ol><li><p>prefix + h：往左跳</p></li><li><p>prefix + j：往上跳</p></li><li><p>prefix + k：往下跳</p></li><li><p>prefix + l：往右跳</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*F-mk4CsL1oh36EDK_cRr0g.gif"></p><h3 id="用-vim-的方向鍵縮放視窗"><a href="#用-vim-的方向鍵縮放視窗" class="headerlink" title="用 vim 的方向鍵縮放視窗"></a>用 vim 的方向鍵縮放視窗</h3><ol><li><p>prefix + shift + h：視窗邊界往左移</p></li><li><p>prefix + shift + j：視窗邊界往上移</p></li><li><p>prefix + shift + k：視窗邊界往下移</p></li><li><p>prefix + shift + l：視窗邊界往右移</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*lv0mJUFUVHmxCZMPuctZRg.gif"></p><h3 id="tmux-copycat"><a href="#tmux-copycat" class="headerlink" title="tmux copycat"></a><a href="https://github.com/tmux-plugins/tmux-copycat">tmux copycat</a></h3><p>tmux copycat 可以讓你不使用滑鼠就能夠複製文字。這個套件非常好用，礙於時間不夠無法錄製完整操作。殘念。</p><h3 id="tmux-resurrect"><a href="#tmux-resurrect" class="headerlink" title="tmux-resurrect"></a><a href="https://github.com/tmux-plugins/tmux-resurrect">tmux-resurrect</a></h3><p>讓系統重啟的時候保持 tmux 的設定。</p><h3 id="tmux-open"><a href="#tmux-open" class="headerlink" title="tmux-open"></a><a href="https://github.com/tmux-plugins/tmux-open">tmux-open</a></h3><p>能夠讓你快速的打開你選取到的文字對應的超連結或是檔案。</p><h3 id="tmux-prefix-highlight"><a href="#tmux-prefix-highlight" class="headerlink" title="tmux-prefix-highlight"></a><a href="https://github.com/tmux-plugins/tmux-prefix-highlight">tmux-prefix-highlight</a></h3><p>讓你知道你有沒有成功觸發 prefix，如果按成功了，在下方顯示列會有成功觸發的圖案。</p><h3 id="tmux-continuum"><a href="#tmux-continuum" class="headerlink" title="tmux-continuum"></a><a href="https://github.com/tmux-plugins/tmux-continuum">tmux-continuum</a></h3><p>持續幫你儲存 tmux 的設定。</p><h3 id="tmux-sensible"><a href="#tmux-sensible" class="headerlink" title="tmux-sensible"></a><a href="https://github.com/tmux-plugins/tmux-sensible">tmux-sensible</a></h3><p>讓 tmux 比較合乎邏輯，不然 tmux 有些預設的設定實在是有點難用，這是必備的 tmux 套件。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>有了 tpm 可以輕鬆安裝好用套件，這讓 tmux 平易進人多了，操作上不再需要記憶太多奇怪的快捷鍵。就可以讓生產力獲得大幅的提升，真滴好。</p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><p><a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">Making tmux Pretty and Usable — A Guide to Customizing your tmux.conf</a></p></li><li><p><a href="https://medium.com/actualize-network/a-minimalist-guide-to-tmux-13675fb160fa">A minimalist guide to tmux</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近因為工作上需要用到開很多個視窗的情景，研究了一下如何把 tmux 變得更具有生產力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/0*wJrJdR3tFO84Tdsd.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unit Test 中的替身：搞不清楚的 Dummy 、Stub、Spy、Mock、Fake</title>
    <link href="https://luka.tw/uncategorized/past/2020-05-05-unit-test-3f5ca0b52a12/"/>
    <id>https://luka.tw/uncategorized/past/2020-05-05-unit-test-3f5ca0b52a12/</id>
    <published>2020-05-05T11:50:00.000Z</published>
    <updated>2022-11-27T21:26:12.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hackmd.io/_uploads/S1amZHerK.png"></p><p>最近開始接觸單元測試，一堆名詞看不懂，來狠狠地 K 一下。而單元測試中的最佳男配角，就是替身 Double。藉由寫一篇文章的方式來讓自己更了解單元測試中的重要部分。一起來學寫測試，Go Go !!</p><blockquote><p> <em>註：接觸時間還很短，有錯還請不吝指正，如果之後發現我有理解錯誤再回來更正。</em></p></blockquote><h2 id="單元測試是什麼？"><a href="#單元測試是什麼？" class="headerlink" title="單元測試是什麼？"></a>單元測試是什麼？</h2><p>單元測試可以讓你快速驗證程式的行為。了解單元測的話首先來介紹一下 SUT 目標對象。</p><p>舉個例子：你想要測試一台車是不是可以開，那麼 SUT 目標對象就是這台車。</p><p>為了確保這台車可以開，那麼就可以寫一個「這台車應該要可以開」的測試。如果這台車發生了故障，測試就會告訴你，這台車是壞掉的。</p><p>單元測試讓你的程式更容易維護。原因在於你能夠對程式寫測試，代表你寫的程式的「使用說明書」清楚易懂。使用說明書很容易懂，就可以直接拿來用，減少重複的程式碼，符合 DRY (Don’t Repeat Yourself) 原則。</p><p>寫程式最大的成本在於維護，寫很簡單，但是要維護可就是個不容易的事情了。為了降低維護的成本，導入單元測試可以大大降低出錯的可能性，並且快樂地重構。</p><h2 id="替身是什麼？"><a href="#替身是什麼？" class="headerlink" title="替身是什麼？"></a>替身是什麼？</h2><p>下圖是火影忍者的替身之術，替身之術的原理是：當敵人對你發動攻擊時，你使用替身之術，就可以讓替身承受敵人的攻擊，而自己不會受到傷害。圖中的木頭就是呼叫替身之術後，用來承受敵人攻擊的替身。</p><p><img src="https://hackmd.io/_uploads/BJ04bHxSF.png"></p><p>所以火影忍者替身之術跟 Unit Test 的替身有什麼關係？你在程式中使出替身之術的時候，替身 Double 就會出現在你的程式裡面了。</p><h2 id="為什麼要在程式中使用替身-Double-呢？"><a href="#為什麼要在程式中使用替身-Double-呢？" class="headerlink" title="為什麼要在程式中使用替身 Double 呢？"></a>為什麼要在程式中使用替身 Double 呢？</h2><p>原因在於你想要測試的 SUT 目標對象通常會有很多「依賴」DOC。一樣舉個例子：剛剛的 SUT 目標對象是「一台車」很容易寫測試，只要測試這台車可以開就好。</p><p>但是如果一台車停在停車場，然後又爆胎。或是一台車掉到海裡。這些情況，一台車的 DOC 依賴變多了，造成你的測試更加複雜，越多的 DOC 依賴會造成你的測試越難寫，也造成你的程式行為更加複雜，難以預測。</p><p>那麼就進入正題來介紹測試中的幾種替身吧</p><h2 id="測試中的五種替身"><a href="#測試中的五種替身" class="headerlink" title="測試中的五種替身"></a>測試中的五種替身</h2><p>測試中的 Double 替身分為五種：Dummy Object、Test Stub、Test Spy、Mock Object、Fake Object。先來介紹第一種 Dummy Object 冒牌貨</p><h3 id="Dummy-Object"><a href="#Dummy-Object" class="headerlink" title="Dummy Object"></a>Dummy Object</h3><p>Dummy Object 英文直譯冒牌貨，顧名思義就是個冒牌貨。他的用途是用來填充 SUT 目標測試對象中需要的物件。而 Dummy 不會對 SUT 測試目標造成任何的影響。純粹的填充物件，讓測試程式能夠運行。</p><h3 id="Test-Stub"><a href="#Test-Stub" class="headerlink" title="Test Stub"></a>Test Stub</h3><p>我們想要驗證的 SUT 回傳值，這時候 Stub 就可以派上用場啦。聽起來有點玄，一樣舉個例子：例如：現在我們的測試目標 SUT 是一個手電桶，我們想要驗證呼叫打開 on 方法的結果，而一個手電筒裡面需要裝電池，電池可能會沒電，但是我不想讓電池沒電這個因素影響我的測試。所以我做了一組替身電池 (Stub Object) 塞進這個手電筒裡面。讓我可以輕鬆驗證 SUT 的回傳值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flashlight</span></span><br>  attr <span class="hljs-symbol">:battery</span>  <br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(battery)</span></span><br>    <span class="hljs-variable">@battery</span> = battery<br>  <span class="hljs-keyword">end</span>  <br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on</span></span><br>    battery.have_energy? ? <span class="hljs-string">&#x27;flashlight is turn on!&#x27;</span> : <span class="hljs-string">&#x27;no energy&#x27;</span><br>  <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br><br>Flashlight.new(StubBattery.new).on <span class="hljs-comment"># 電池有沒有電不會影響結果。</span><br></code></pre></td></tr></table></figure><h3 id="Test-Spy"><a href="#Test-Spy" class="headerlink" title="Test Spy"></a>Test Spy</h3><p>Spy 用來驗證 SUT 與對其他 DOC 物件造成的效果，例如：今天阿牛去找朋友聊天的時候，朋友物件內部的聊天次數就會加一，而當我們想想要驗證朋友物件的聊天次數是不是如我們所預期的增長時，我們就可以派出間諜朋友，來驗證「 SUT 阿牛是否有跟朋友聊三次天」之類的期待。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> 阿牛  </span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(friend)</span></span><br>    <span class="hljs-variable">@friend</span> = friend<br>  <span class="hljs-keyword">end</span>  <br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chat_to_friends</span></span><br>    friend.chat!<br>  <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Friend</span> </span><br>  <span class="hljs-symbol">attr:</span> chat_count  <br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chat</span></span><br>    <span class="hljs-variable">@chat_count</span> <span class="hljs-params">||</span>= <span class="hljs-number">0</span><br>    <span class="hljs-variable">@chat_count</span> += <span class="hljs-number">1</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>cow = 阿牛.new(spy_friend)<br><br>cow.chat_to_friends<br>cow.chat_to_friends<br>cow.chat_to_friends<br><br>expect(spy_friend.chat_count).to eq(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="Mock-Object"><a href="#Mock-Object" class="headerlink" title="Mock Object"></a>Mock Object</h3><p>Mock 是一個能夠判斷 SUT 是不是有正確使用 DOC 的替身。Mock 跟 Spy 的最大差別是，Mock 用來驗證 SUT 的行為，而 Spy 用來驗證 SUT 對 DOC 狀態的改變。</p><h3 id="Fake-Object"><a href="#Fake-Object" class="headerlink" title="Fake Object"></a>Fake Object</h3><p>Fake Object 假物件是一個簡化的 DOC (依賴元件)，例如：一台真實的飛機有很多零件，但是我們其實只需要他有外殼，並且可以飛，可以降落 … 等等的行為。所以做一個簡單版的假物件。假物件不需要考慮跟 SUT 目標對象的間接互動(Indirect input , indirect output)。</p><h2 id="其他不錯的資源"><a href="#其他不錯的資源" class="headerlink" title="其他不錯的資源"></a>其他不錯的資源</h2><ul><li><a href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da">Test Doubles — Fakes, Mocks and Stubs.</a></li><li><a href="https://julianchu.net/2018/08/16-test.html">測試中常見的名詞：Stub, Dummy, Mock..等等</a></li><li><a href="https://www.jyt0532.com/2018/01/04/test-double-spy/">測試替身(5) — Spy</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/S1amZHerK.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近開始接觸單元測試，一堆名詞看不懂，來狠狠地 K 一下。而單元測試中的最佳男配角，就是替身 Double。藉由寫一篇文章的方式來讓自己更了解單元測試中的</summary>
      
    
    
    
    
    <category term="Unit Test" scheme="https://luka.tw/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 教學 02 — 在 Minikube 上部屬 Python Flask 應用程式</title>
    <link href="https://luka.tw/uncategorized/past/2020-03-20-running-flask-on-minikube-0ad6ec86a505/"/>
    <id>https://luka.tw/uncategorized/past/2020-03-20-running-flask-on-minikube-0ad6ec86a505/</id>
    <published>2020-03-10T11:50:00.000Z</published>
    <updated>2022-11-27T21:26:12.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Minikube、kubectl 終於派上用場囉</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2088/0*BVfI3gXXICtmPkCu.jpeg"></p><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在 <a href="https://medium.com/starbugs/954caa9b1558">前一篇</a> 中我們弄懂了 K8S Cluster、Node、Pod 與 Container 的關係，並且在文章末段介紹了能夠與 kubectl -「能夠與 K8S 溝通的命令列工具」。這次我們用實際的操作，來認識容器化的實際過程，並把它部屬到本地的 Kubernetes 上面。</p><h2 id="什麼是-Minikube-？"><a href="#什麼是-Minikube-？" class="headerlink" title="什麼是 Minikube ？"></a>什麼是 Minikube ？</h2><p>Minikube 是一個單節點的 Kubernetes Cluster，可以安裝在本機上，支援 Windows 與 Mac Minikube 只有一個 Node (節點)。</p><p>還記得 Node 是什麼嘛？來複習一下，Node 是一台實體機器，一個工作者 (worker)。上面可以搭載許多個 Pod，而 Pod 是 Kubernetes 的最小部屬單位。一個 Pod 由一個 Container 或是多個 Container 所組成。</p><p>看完之後應該還是覺得有點繞，不過沒關係，因為今天我們就要透過實作來了解 Pod 到底是什麼。</p><h3 id="安裝-Minikube"><a href="#安裝-Minikube" class="headerlink" title="安裝 Minikube"></a>安裝 Minikube</h3><p>首先安裝 Minikube，請到<a href="https://kubernetes.io/docs/tasks/tools/install-minikube/">官方網頁</a>下載安裝，Windows、Mac、Linux 都可以安裝。</p><p>Windows 需要先安裝 <a href="https://chocolatey.org/">Chocolatey</a> 套件管理工具，接著輸入指令</p><pre><code>choco install minikube</code></pre><p>即可完成安裝。而 Mac 則可以透過 homebrew 來完成安裝</p><pre><code>brew install minikube </code></pre><h2 id="起步走，開始使用-Minikube-與-kubectl"><a href="#起步走，開始使用-Minikube-與-kubectl" class="headerlink" title="起步走，開始使用 Minikube 與 kubectl"></a>起步走，開始使用 Minikube 與 kubectl</h2><p>安裝完 minikube 之後，第一步先啟動 Minikube，如果你是第一次啟動，Minikube 會幫你建立新的虛擬機器 (VM)。</p><pre><code>minikube start</code></pre><p>眼尖的你看到最後一行，啟動好 minikube 的同時，kubectl 也準備就緒了。來看看 minikube 的狀態。</p><pre><code>minikube status</code></pre><p>上一篇提到的 kubelet 與 api-server 已經成功跑起來。複習一下 api-server 是 Master 的元件，kubelet，則是 Node 上負責跟 Master 溝通的元件。因為 Minikube 只有單一個 Node，所以同時具備 Master 與 Node 的元件。</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*g0EkSg37jwB0wHNb.png"><br><a href="https://kubernetes.io/docs/concepts/overview/components/">ref: https://kubernetes.io/docs/concepts/overview/components/</a></p><p>使用 kubectl 查看目前 Cluster 中的狀態</p><pre><code>kubectl get all</code></pre><p>裡面只有一個 kubernetes 的 service，因為我們的 Kubenetes Cluster 中還沒有安裝任何的東西。</p><h2 id="建立一個-Python-的-Flask-Web-應用程式"><a href="#建立一個-Python-的-Flask-Web-應用程式" class="headerlink" title="建立一個 Python 的 Flask Web 應用程式"></a>建立一個 Python 的 Flask Web 應用程式</h2><p>建立資料夾名稱為 flask_app</p><pre><code>mkdir flask_app</code></pre><p>建立一個子資料夾 app ，並在之中建立一個 app.py 檔案</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"> <span class="hljs-comment"># flask_app/app/app.py</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, World!&quot;</span><br><br><br><span class="hljs-keyword">if</span> __name == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(debug=<span class="hljs-literal">True</span>, host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>建立 requirement.txt</p><pre><code># flask_app/app/requirement.txtFlask</code></pre><p>在本地端試跑，先安裝依賴的套件，目前只有一個就是 flask</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pip3 install -r requirements.txt<br></code></pre></td></tr></table></figure><p>接著執行看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">python main.py<br></code></pre></td></tr></table></figure><p>打開 <a href="http://0.0.0.0:5000/">0.0.0.0:5000</a> 即可看到以下訊息</p><pre><code>Hello from Python!</code></pre><h2 id="容器化-Flask-Web-應用程式"><a href="#容器化-Flask-Web-應用程式" class="headerlink" title="容器化 Flask Web 應用程式"></a>容器化 Flask Web 應用程式</h2><p>建立一個 Dockerfiile，意思是用 Python 3.7 作為基本的容器，並把專案中的程式碼放進去。並在最後執行 python main.py。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> mkdir /app</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><br><span class="hljs-keyword">ADD</span><span class="bash"> ./app /app/</span><br><span class="hljs-keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;/app/main.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>製作 docker image，並給他一個名稱flask_app</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">docker build . -t flask_app<br></code></pre></td></tr></table></figure><p>可以成功 build，沒有問題</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*bSSrv5vrsVqBO2xGZbs0qA.png"></p><p>用 docker images 查看剛剛製作的 image</p><p><img src="https://cdn-images-1.medium.com/max/2140/1*ta80syB_HoOKMwLmSLOdQA.png"></p><p>跑跑看剛剛製作好的 image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">docker run -p 5001:5000 flask_app<br></code></pre></td></tr></table></figure><p>打開 <a href="http://0.0.0.0:5001/">http://0.0.0.0:5001/</a> 一樣會看到</p><pre><code>Hello from Python!</code></pre><p>到這邊我們已經製作完成 Docker image。接下來就要把它部屬到 Minikube 上。</p><h2 id="部屬-Python-Flask-應用程式到-Minikube-上"><a href="#部屬-Python-Flask-應用程式到-Minikube-上" class="headerlink" title="部屬 Python Flask 應用程式到 Minikube 上"></a><strong>部屬 Python Flask 應用程式到 Minikube 上</strong></h2><p>首先我們先來建立一個檔案 k8s.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">flask-app-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">flask-app</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">&quot;TCP&quot;</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5000</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">5000</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">flask-app</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">flask-app</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">flask-app</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">flask-app</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">flask_app:latest</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Never</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><p>命令列輸入，即可將 flask_app 部屬至 minikube</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">kubectl apply -f k8s.yaml<br></code></pre></td></tr></table></figure><p>部屬完的畫面</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*G45yB7h77nfGQ--OtDgG1A.png"></p><p>接著訪問</p><p>剛剛的 k8s.yaml 只有聲明 deployment 與 service 兩種物件，但卻產生了 3 個 pod，原因就在於，deployment 裡面聲明了需要 3 個 pod，所以會擴展出 3 個。</p><p>輸入以下指令查看暴露出來的 IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">minikube service flask-app-service --url<br></code></pre></td></tr></table></figure><p>訪問 <a href="http://192.168.64.8:30914/">http://192.168.64.8:30914</a> 就可以看到 Kubernetes 上的 Flask 伺服器回傳的畫面。</p><pre><code>Hello from Python!</code></pre><p>剛剛我們撰寫 k8s.yaml 時，Service Type 使用的是 LoadBalancer，所以這可是具有負載均衡能力，並且擁有 3 個 Pod 作為支撐的服務。</p><p>是不是很神奇？今天我們做了三種 Hello from Python，分別是：</p><ul><li><p>在本地端運行 Flask 伺服器</p></li><li><p>在單個 Docker 容器運行 Flask 伺服器</p></li><li><p>在 Kubernetes 中的 Cluster 運行 Flask 伺服器</p></li></ul><p>一步一步的將應用程式，容器化，之後再用 K8S 打造成產品等級的服務。Kubernetes 就是這麼的有趣！</p><p>如果喜歡我寫的文章，歡迎追蹤 本人的帳號 <a href="https://medium.com/@LukaTw">@LukaTW</a> 與 <a href="https://medium.com/starbugs">StarBugs Weekly 星巴哥技術週刊</a> 🙂🙂🙂</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Minikube、kubectl 終於派上用場囉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2088/0*BVfI3gXXICtmPkCu.jpeg&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="Kubernetes" scheme="https://luka.tw/tags/Kubernetes/"/>
    
    <category term="Minikube" scheme="https://luka.tw/tags/Minikube/"/>
    
    <category term="Python" scheme="https://luka.tw/tags/Python/"/>
    
    <category term="Flask" scheme="https://luka.tw/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 教學 01 - 概念與架構</title>
    <link href="https://luka.tw/uncategorized/past/2020-02-11-kubernetes-tutorial-01-cd76ae4c25e5/"/>
    <id>https://luka.tw/uncategorized/past/2020-02-11-kubernetes-tutorial-01-cd76ae4c25e5/</id>
    <published>2020-02-11T02:32:00.000Z</published>
    <updated>2023-04-25T07:10:47.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="為什麼該學-K8S-？-Pod、Node-是什麼？搞的我好亂呀！"><a href="#為什麼該學-K8S-？-Pod、Node-是什麼？搞的我好亂呀！" class="headerlink" title="為什麼該學 K8S ？ Pod、Node 是什麼？搞的我好亂呀！"></a>為什麼該學 K8S ？ Pod、Node 是什麼？搞的我好亂呀！</h2><p><img src="https://hackmd.io/_uploads/BJvr9reBt.png"></p><p>適合讀者：</p><ul><li><p>已經會使用 Docker，但是不知道 Kubernetes 是什麼。</p></li><li><p>想看看 Kubernetes 到底在幹嘛的人。</p></li></ul><h2 id="為什麼該用-Kubernetes"><a href="#為什麼該用-Kubernetes" class="headerlink" title="為什麼該用 Kubernetes?"></a>為什麼該用 Kubernetes?</h2><p>Kubernetes 中間共有八個字母有點長，所以大家就將他簡稱為 K8S。但使用 K8S 有什麼好處？</p><h3 id="1-可以更好的運用雲端或是實體資源"><a href="#1-可以更好的運用雲端或是實體資源" class="headerlink" title="1. 可以更好的運用雲端或是實體資源"></a>1. 可以更好的運用雲端或是實體資源</h3><p>所有的資源集中成了一個大平台，所以調度上更靈活，以往我們以實體機為單位的方式很沒有效率，要調度資源的時候需要開一台實體機器，或是虛擬機器，都很耗費 CPU、記憶體等等的資源。</p><p>而 K8S 內所有的東西都是容器，可以很快啟動，很快的刪除，並且靈活部屬在 Kubernetes 所擁有的資源上。</p><h3 id="2-讓一切的基礎設施都寫成程式碼"><a href="#2-讓一切的基礎設施都寫成程式碼" class="headerlink" title="2. 讓一切的基礎設施都寫成程式碼"></a>2. 讓一切的基礎設施都寫成程式碼</h3><p>應用程式容器化之後，所有需要安裝的套件都會寫成 Dockerfile。這樣在新增或修改的時候，不再像是以前的伺服器是個黑盒子，需要花大量的時間除錯。</p><p>部屬的資源則用 Kubernetes 的描述方式撰寫，要前端服務要開幾台，後端服務要開幾台，要自動擴展？ 沒問題，這些 K8S 都可以輕鬆幫你做到。所以你如果要了解整個基礎設施架構時，可以很快的藉由程式碼來認識。</p><h3 id="3-可以幫助開發者聚焦開發"><a href="#3-可以幫助開發者聚焦開發" class="headerlink" title="3. 可以幫助開發者聚焦開發"></a>3. 可以幫助開發者聚焦開發</h3><p>減少開發者在基礎設施上花的時間，將硬體統一看做一個大平台，開發者只需要寫應用的描述，其他的 K8S 幫你搞定。例如：有節點當機，會自動生成一個新的節點，以維持服務的穩定。</p><h2 id="一切從-Container-開始"><a href="#一切從-Container-開始" class="headerlink" title="一切從 Container 開始"></a>一切從 Container 開始</h2><p>使用 Kubernetes 之前，你需要把你的服務先容器化，或者用人家包好的 Image 建立。例如：你有一個 Node.js 的應用程式、一個 MySQL 的資料庫，都可以架設在 K8S 上面。</p><p>K8S 提供了豐富的、可以應用於產品環境的一切資源給你。例如：自動擴展、負載均衡、定時工作 … 等等一切你想得到的東西。</p><p>但是在開始使用 K8S 之前，你需要把你的服務先容器化。雖然一開始很痛苦，需要花很多時間做原本不必要做的事情，但是你容器化你的服務之後會發現，以前需要在不知道被做過什麼事情的機器上摸索的體力活，通通都自動化、或是很易於找到解法，因為在程式碼裡面都有跡可尋。</p><h2 id="理解-Node、Pod、Container-之間的關係"><a href="#理解-Node、Pod、Container-之間的關係" class="headerlink" title="理解 Node、Pod、Container 之間的關係"></a>理解 Node、Pod、Container 之間的關係</h2><p>Node 是 K8S 中的一台實體機器、或是雲端上的一台機器，又稱作是工作者。他有個別名叫做奴隸 (minion) ，挺有趣的。</p><p>Pod 是 K8S 中基本的單位，負責裝一個或多個多個 Container (容器)。</p><p>Container 中就是我們容器化好的應用程式，例如：Node.js 應用程式、MySQL 服務 … 等等</p><p>需要 Pod 來作為基本單位的原因是，如果每個 Container 都作為 K8S 的最小單位，那麼管理網路會變得非常的困難。以 Pod 來區隔，同一個 Pod 裡面的 Container 能夠在本地端互相的連線，只有需要提供給外部呼叫的 API 才需要暴露出來。</p><p>示意圖如下：</p><p><img src="https://hackmd.io/_uploads/SkEGjSeSF.png"></p><h2 id="理解-Kubernetes-Cluster"><a href="#理解-Kubernetes-Cluster" class="headerlink" title="理解 Kubernetes Cluster"></a>理解 Kubernetes Cluster</h2><p>Kubernetes 集群由控制面板 Control Panel 與節點 Node 所組成。控制面板又稱為是 Kubernetes Master。</p><p><img src="https://hackmd.io/_uploads/H1J7oHgrK.png"></p><p>控制面板由幾個元件 (Component) 所組成：</p><h3 id="1-Kube-API-Server"><a href="#1-Kube-API-Server" class="headerlink" title="1. Kube API Server"></a>1. Kube API Server</h3><p>控制面板中用來暴露 Kubernetes API 的元件，讓其他服務可以讀寫 K8S 的資源物件 (Resouce Object)。</p><h3 id="2-Kube-Schedular"><a href="#2-Kube-Schedular" class="headerlink" title="2. Kube Schedular"></a>2. Kube Schedular</h3><p>調度器，需要調度軟體、硬體資源的時候就要靠調度器囉。例如：如果新建立的 pod 沒有 node 可以放的時候，調度器就會開啟一個新的 node，來放置剛剛需要建立的 pod。</p><h3 id="3-Kube-Controller-Manager"><a href="#3-Kube-Controller-Manager" class="headerlink" title="3. Kube Controller Manager"></a><strong>3. Kube Controller Manager</strong></h3><p>是一個在背景持續執行的程式 (daemon)，用來調節系統狀態，透過 api-server 可以監視 Cluster 共享的狀態。</p><p>需要變更目前狀態的時候 Kube Controller 就會將目前的狀態變更到想要變更的狀態，例如：本來 2 個副本 (Replica) 擴展到 4 個副本。</p><p>包含了副本控制器 (Replication Controller)，端點控制器 (Endpoint Controller)、命名空間控制器(Namepsace Controller)與服務帳號控制器</p><h3 id="4-Cloud-Controller-Manager"><a href="#4-Cloud-Controller-Manager" class="headerlink" title="4. Cloud Controller Manager"></a><strong>4. Cloud Controller Manager</strong></h3><p>基於 Kube Controller Manager，各個雲平台提供者（Provider）的實作。而每個 Node 則包含：</p><ul><li><p>kubelet — 用來跟 Master 溝通的元件。</p></li><li><p>kube-proxy — 網路代理，用來反應 K8S 各個 Node 上的網路服務</p></li></ul><h2 id="讀-Kubernetes-API-初探-K8S-的資源物件"><a href="#讀-Kubernetes-API-初探-K8S-的資源物件" class="headerlink" title="讀 Kubernetes API 初探 K8S 的資源物件"></a>讀 Kubernetes API 初探 K8S 的資源物件</h2><p>我們可以透過 Kubernetes API 讀寫 K8S 的資源物件 (Resource Object)，剛剛說的 Kubernetes Cluster 就分為 Kubernetes API 總共分為五大類，分別是：</p><ul><li><p>Workload 物件 — 用來「管理或是運行 Container」 在 Cluster 上。</p></li><li><p>服務發現與負載均衡物件 — 讓 Workload 可以「縫住」形成可被外部存取到的服務，或是有負載均衡能力的服務。</p></li><li><p>Config 與 Storage 物件 — Config 用來將設定注入你的應用程式中。Storage 讓 Container 的資料可以永久保存在 Container 之外。</p></li><li><p>Cluster 物件 — 用來定義集群本身的物件。</p></li><li><p>Meta 物件 — 用來設定資源之間的行為的物件。</p></li></ul><p>這種分類法較接近開發者，可以藉此看看開發者在想些什麼。</p><p><img src="https://hackmd.io/_uploads/HyqXjSlHY.png"></p><p>還有精美的 kubectl 範例可以使用，很方便。</p><p><img src="https://hackmd.io/_uploads/SJZVoSlSF.png"></p><h2 id="kubectl-—-跟-K8S-Cluster-溝通的工具"><a href="#kubectl-—-跟-K8S-Cluster-溝通的工具" class="headerlink" title="kubectl — 跟 K8S Cluster 溝通的工具"></a>kubectl — 跟 K8S Cluster 溝通的工具</h2><p>我們絕大多數對 K8S 的操作都需要透過 kubectl，kubectl 的是什麼呢？DevOps 開發者用 kubectl 命令列工具，可以透過 Kubernetes Master 上的 api-server 對各個 Node 下達指令。而這些 API 即是上一小節說的 Kubernetes API。</p><p><img src="https://hackmd.io/_uploads/SkjEjBgHt.png"></p><p>to be continued …</p><p>下一部分會比較偏重實作， Minikube 的基本操作、Kubectl 的基本操作與重要的 資源物件的介紹。</p><p>如果喜歡我寫的文章，歡迎追蹤 本人的帳號 <a href="https://medium.com/@LukaJoJo">@LukaJoJo</a> 與 <a href="https://medium.com/starbugs">StarBugs Weekly 星巴哥技術週刊</a> 🙂🙂🙂</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;為什麼該學-K8S-？-Pod、Node-是什麼？搞的我好亂呀！&quot;&gt;&lt;a href=&quot;#為什麼該學-K8S-？-Pod、Node-是什麼？搞的我好亂呀！&quot; class=&quot;headerlink&quot; title=&quot;為什麼該學 K8S ？ Pod、Node 是什麼？搞的我</summary>
      
    
    
    
    
    <category term="Kubernetes" scheme="https://luka.tw/tags/Kubernetes/"/>
    
    <category term="Minikube" scheme="https://luka.tw/tags/Minikube/"/>
    
  </entry>
  
</feed>
